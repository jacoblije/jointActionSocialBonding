% File name: trainingExperimentFinalAnalysis.R
% Author: Jacob Taylor
% Date Created: 20/09/2017
% Description: A script for analysing complete data from trainingExperiment in Weihai and Beijing during August 2016.
% This analysis incorporates performance data coded from video recordings of each experimental session.

\documentclass[english]{article}
\usepackage[utf8]{inputenc}
\usepackage[margin=1.8cm,a4paper]{geometry}
\usepackage[english]{babel} % hyphenation
\usepackage{csquotes}
\usepackage{amsmath,amssymb,amsthm} % for mathematical
\usepackage{graphicx} % to include graphics
\newcommand{\myparagraph}[1]{\paragraph{#1}\mbox{}\\}


%%Bib Setup:
\usepackage[style=apa, sorting=nyt, backend=biber, maxcitenames=2, useprefix=true, doi=false, isbn=false, natbib=true, language=american]{biblatex}
\DeclareLanguageMapping{american}{american-apa}
\newcommand*{\bibtitle}{Works Cited}
\addbibresource{references.bib}

%%In-text \Sexpr{} setup for lmer:
\newcommand{\betavec}{{\bm\beta = }}
\newcommand{\CIstart}{(95\% CI =}
\newcommand{\CIfinish}{),}
\newcommand{\SE}{SE =}
\newcommand{\pvalue}{p =}
\newcommand{\MR2}{marginal R^2 =}
\newcommand{\CR2}{conditional R^2 =}
% Wald statistic for normality of residuals:
\newcommand{\resdist}{W = }
% Cook's Distances (influential cases)
\newcommand{\cooksD}{Cook's Distances}

% setting global settings and loading useful libraries
\title{Field Experiment}
\date{}
\author{Jacob Taylor & Emma Cohen \\ Institute of Cognitive \and Evolutionary Anthropology, University of Oxford}




\begin{document}
\maketitle


<<standardSettings, echo=FALSE, results='hide'>>=

#install.packages("knitr")
  library(knitr)


  opts_knit$set(root.dir = "/Users/jacob1/Documents/2017/Research/DPhil/Dissertation/finalDocuments/jointActionSocialBonding/images/")
  opts_chunk$set(warnings = FALSE, messages = FALSE, results = "hide",
                  fig.width=3.5, fig.height=3.5,fig.align='center', fig.path="/Users/jacob1/Documents/2017/Research/DPhil/Dissertation/finalDocuments/jointActionSocialBonding/images/")

  #install.packages("tidyverse")
  library(tidyverse)
  #install.packages("xtable")
  library(xtable) # to make Latex tables
  #install.packages("tableone")
  library(tableone)
  #install.packages("apa")
  library(apa)
  library(lme4)
  #install.packages("optimx")
  library(optimx)
  library(lmerTest)
  #install.packages("mediation")
  library(mediation)
  #install.packages("car")
  library(car)
  #install.packages("HLMdiag")
  library(HLMdiag)
  #install.packages("influence.ME")
  library(influence.ME)
  #install.packages("piecewiseSEM")
  update.packages("piecewiseSEM")
  library(piecewiseSEM)
  library(mediation)
  #install.packages("Hmisc")
  library(stats)
  #install.packages("ICC")
  library(ICC)
  #install.packages("broom")
  library(broom)


  ##papaja for APA format:
 devtools::install_github("crsh/papaja")

  ##https://sakaluk.wordpress.com/2015/04/13/2-the-ggplot2-package-your-gateway-drug-to-becoming-an-r-user/
  apatheme=theme_bw()+
  theme(panel.grid.major=element_blank(),
        panel.grid.minor=element_blank(),
        panel.border=element_blank(),
        axis.line=element_line(),
        text=element_text(family='Times'),
        legend.title=element_blank())


            #-----------------------Correlation Table----------------------#
            #library(xtable)
            corstarsl <- function(x){
              require(Hmisc)
              x <- as.matrix(x)
              R <- rcorr(x)$r
              p <- rcorr(x)$P

              ## define notions for significance levels; spacing is important.
              mystars <- ifelse(p < .001, "***", ifelse(p < .01, "** ", ifelse(p < .05, "* ", " ")))
              ## trunctuate the matrix that holds the correlations to two decimal
              R <- format(round(cbind(rep(-1.11, ncol(x)), R), 2))[,-1]
              ## build a new matrix that includes the correlations with their apropriate stars
              Rnew <- matrix(paste(R, mystars, sep=""), ncol=ncol(x))
              diag(Rnew) <- paste(diag(R), " ", sep="")
              rownames(Rnew) <- colnames(x)
              colnames(Rnew) <- paste(colnames(x), "", sep="")
              ## remove upper triangle
              Rnew <- as.matrix(Rnew)
              Rnew[upper.tri(Rnew, diag = TRUE)] <- ""
              Rnew <- as.data.frame(Rnew)
              ## remove last column and return the matrix (which is now a data frame)
              Rnew <- cbind(Rnew[1:length(Rnew)-1])
              return(Rnew)
            }

@
<<dataInput, eval=TRUE, echo=FALSE, results='hide'>>=
  setwd("/Users/jacob1/Documents/2017/Research/DPhil/Dissertation/finalDocuments/jointActionSocialBonding/images")
  # read in complete data from experiment:
  tlc <- read.csv("trainingLongComplete.csv", na.strings = c("", "NA", "n/a"))
  twc <- read.csv("trainingWideComplete.csv", na.strings = c("", "NA", "n/a"))
@





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%ABSTRACT%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Abstract}
This study further tested the hypothesised relationship between joint action, team click, and social bonding in a controlled experimental environment.  An experiment was designed to test the prediction, partly confirmed in an \textit{in situ} survey study (Chapter 8 HYPERLINK), that athletes who perceived higher quality team performance in joint action would also experience higher levels of team click and social bonding.  58 Professional Chinese rugby players (Men = \Sexpr{length(which(twc$sex == 0))}) participated in a between-subjects design in which athletes' expectations for joint action training drill \citep[``Invasion drill''][]{Passos2011}) were manipulated in one of two conditions.  Athletes in the ``low difficulty'' condition were primed with information to suggest that the training drill would require minimal rugby-sepcific individual and joint-action competence (i.e., 2/10 difficulty rating).  By contrast, in the ``high difficulty'' condition, athletes were primed to expect the training drill to be relatively difficult (8/10 difficulty rating). Pre- and post-experiment surveys were conducted, measuring athletes' perceptions of main variables of interest (individual and group performance, team click, and social bonding (both to the training group and the team more generally)), as well as athlete personality type and states of athlete states of arousal, fatigue, and injury.  Video footage of each experimental session was also recorded to derive an objective measure of interpersonal coordination not reliant on self-report. It was predicted that athletes in the ``high-difficulty'' condition would experience higher levels of team click and social bonding due to higher positive violation of expectations around group performance.  Athletes in the ``low difficulty'' condition would on average experience less strongly the ``click'' of joint action and social bonding because they would not experience the same level of positive violations of expectations around group performance.  Results provided some confirmation of these predictions.

%Video footage was analysed for evidence of dynamic coupling between co-actors as well as defenders \citep{Schmidt2011,Richardson2012,Passos2012}, and these data were compared to psychological measures in order to explore psychological correlates of effective  interpersonal movement coordination in joint action.

%for two reasons: 1) athletes with expectations of higher difficulty would pay greater attention to coordinating action with others, and
%


<<interRaterReliability, eval=T, echo=F>>=

videoData <- read.csv("codedVideoData.csv", na.strings = c("n/a", ""))

#1. Clean video data and add new variables:
# 1.1 exlcude warm-up trials from each "clip"
videoDataLean <- videoData[ ! videoData$trial %in% c(1:4), ]
videoDataLean$trial

# 1.2 exclude additional trials:  clip1 trial 13 (immediate dropped ball fail), last two trials from final clip (BJM High uncertainty)
videoDataLean <- videoDataLean[ !(videoDataLean$clip == 1 & videoDataLean$trial == 13), ]


#videoDataLean$fullOutcomeJT <- videoDataLean$fullOutcome
#videoDataLean$sucessJT <- videoDataLean$sucess


#install.packages("fmsb")
library(fmsb)
Kappa.test(videoDataLean$fullOutcomeJT, videoDataLean$fullOutcome)
Kappa.test(videoDataLean$successJT, videoDataLean$success)
library(ICC)
  # groupConfidence
reliabilityICC <- ICCbare(fullOutcomeJT, fullOutcome, data = videoDataLean)






@













%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%INTRODUCTION%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%SECTION%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




\section{Introduction}

The previous chapter presented empirical evidence of a relationship between perceptions of joint action success and social bonding, fully mediated by the phenomenon of ``team click.'' A relationship between violation of expectations surrounding team performance and feelings of team click was also observed, but a model of the relationship between team performance expectation vioaltion and social bonding did not reliably fit the data.  The results of this naturalistic \textit{in situ} study are noteworthy as they provide evidence for the prediction that perceptions of joint action influence psychological processes of affiliation and connection with teammates, possibly via the mediating construct of ``team click.''  Controlled experimental research is needed in order to more directly access causal mechanisms that underpin the relationship between joint action and social bonding.  If perceived joint action success and positive violation of expectation around team performance are the two candidate predictors of team click and social bonding, how is it possible to experimentally manipulate conditions conducive to maximising these two factors in joint action? In addition, how is it possible to isolate joint action from other potential sources of information regarding the team and its performance such as explicit feedback from coaches and other players surrounding performance and joint action outcome? This experimental study was designed with these considerations in mind.

The Lit Review:
%begin by describing a phenomenon in a general way along with several studies that demonstrate it, then describing two or more competing theories of the phenomenon, and finally presenting a hypothesis to test one or more of the theories.
1. Re-cap literature (Synchrony, joint action, pink noise, team click)
2. Extend to expectation violation:
3.Priming literature: prime difficulty and uncertainty:
- Challenge to skill ratio - Flow literature.
By manipulating the level of uncertainty of information regarding the expectation


%Immediately after the opening comes the literature review, which describes relevant previous research on the topic and can be anywhere from several paragraphs to several pages in length. However, the literature review is not simply a list of past studies. Instead, it constitutes a kind of argument for why the research question is worth addressing.

%By the end of the literature review, readers should be convinced that the research question makes sense and that the present study is a logical next step in the ongoing research process.   it is extremely important to start with an outline of the main points that you want to make, organized in the order that you want to make them. Or if you are proposing a new theory, then of course you should discuss findings that are consistent with that theory. However, if there are other findings that are inconsistent with it, again, you should discuss them too.



The Closing:
These considerations lead to the hypothesis that expectations of higher levels of technical challenge in joint action will lead to higher levels of social bonding, due to the likelihood that athletes will perceive team performance more positively relative to prior expectations in the high-difficulty prime than in a low difficulty prime.  As predicted in the previous study, it was predicted that the feeling of ``team click'' would mediate the relationship between positive violations of expectations and social bonding.  The predictions are outlined as follows:
\begin{description}
\item[Prediction 1:] More positive violations of expectations around team performance will correlate with higer feelings of team click with the training group
\item[Prediction 1.a:] Violations of expectations around team performance moderate the relationship between perceptions of joint action success and team click training group
\item[Prediction 2:] Feelings of group click will positively correlate with feelings of social bonding to the group
\item[Prediction 3:] More positive violations of team performance expectations will predict higher levels of Social Bonding to the training group
\item[Prediction 4:] Feelings of group click will mediate a relationship between more positive violations of expectations around group performance and social bonding to the group
\end{description}

A between-subjects experimental design was used, in which expectations of technical difficulty was manipulated in one of two conditions, ``high difficulty'' and ``low difficulty'' condition.  Surveys measuring athletes' perceptions of joint action success relative to prior expectations, team click, and feelings of social bonding to the specific training group were recorded both before and after the experiment.

%The closing of the introduction—typically the final paragraph or two—usually includes two important elements. The first is a clear statement of the main research question or hypothesis. This statement tends to be more formal and precise than in the opening and is often expressed in terms of operational definitions of the key variables. The second is a brief overview of the method and some comment on its appropriateness.

%These considerations lead to the hypothesis that the more bystanders to an emergency, the less likely, or the more slowly, any one bystander will intervene to provide aid. To test this proposition it would be necessary to create a situation in which a realistic “emergency” could plausibly occur. Each subject should also be blocked from communicating with others to prevent his getting information about their behavior during the emergency. Finally, the experimental situation should allow for the assessment of the speed and frequency of the subjects’ reaction to the emergency. The experiment reported below attempted to fulfill these conditions (p. 378).






















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%METHOD%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%SECTION%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Method}

%\subsection{Design}
%The design of a study is its overall structure. What were the independent and dependent variables? Was the independent variable manipulated, and if so, was it manipulated between or within subjects? How were the variables operationally defined?

\subsection{Participants}

This study was approved by the University of Oxford’s Central University Research Ethics Committee (SAME/CUREC1A/15-059).



\subsection{Materials}

\begin{figure}[htbp]
  \includegraphics[width = \linewidth]{/Users/jacob1/Documents/2017/Research/DPhil/Dissertation/finalDocuments/jointActionSocialBonding/images/invasionDrill.pdf}
  \caption{The Invasion Drill, adapted from Passos (2011)}
  \label{fig:invasionDrill}
\end{figure}

\subsubsection{Experimental Paradigm: Invasion Drill}
This study required athletes to participate in a common rugby training drill, which was preceeded by one of two experimental primes—--a ``high difficulty'' condition, or a ``low difficulty'' condition.   Replicating \textcite{Passos2011}, a common training drill known as ``invasion drill'' \citep{Biscombe1998} was selected as it was representative of a typical subphase of joint action in rugby union.
In this drill, a group of four rugby players form an attacking group and two pairs of opponents form a first and second defensive line.  There were two performance aims of this drill: (a) attackers were asked carry the ball into the try area, and (b) defenders were asked to stop the attacker’s progression toward the try line.
One trial consisted of one attempt by the attacking sub-group to penetrate two defending sub-groups, and carry the ball over the try line. The drill was conducted on a regulation multipurpose 110m x 70m grass or artificial turf training field within a 22m x 15m rectangle area marked by plastic cones (see Figure ~\ref{fig:invasionDrill}). The ball used was size 5, as recommended by World Rugby for this age group of athletes.

%The training drill, known as ``invasion drill,'' requires eight athletes, one sub-grouof four attackers and two sub-groups of two defenders.  The primary aim of the drill is for the sub-group of 4 attacking players to successfully penetrate two consecutive lines of two defenders (also commonly known as a ``4 on 2 + 2'' drill). The aim of the two defending sub-groups is to stop the attacking team from achieving the primary goal, by interfering with their coordination by halting the ball-carrier, or the ball in flight between attacking players.


\subsubsection{Experimental Conditions: high and low difficulty}
Two different pre-experiment primes were developed for the same training drill in order to manipulate athletes’ expectations around the technical difficulty of the impending joint-action task.  Athletes in the ``high difficulty'' condition learned that the overall average difficulty rating for the training drill, provided by World Rugby coaches and athletes, was 77.5/100, or approximately 8 out of 10.  Athletes were told that the drill would require an extension of their abilities as individuals and as a training group (see appendix for full script).  Athletes in the ``low difficulty'' condition, by contrast, learned that they would be participating in an ostensibly different drill with an overall average difficulty rating (provided by World Rugby coaches and athletes) of 22.5/100, or approximately 2 out of 10.  In reality, the training drill was exactly the same for each experimental session, and the relative difficulty of this drill was estimated in a pilot study to be approximately 5/10, see APPENDIX).  By either over- or under-rating the difficulty of the impending training drill, athletes' expectations around certainty of performance would be altered, such that athletes in the high difficulty condition would experience on average higher (positive) violation of expectations around team performance, whereas athletes in the low difficulty condition would on average perceive team performance less positively relative to prior of expectations. Surveys were designed and administered using Qualtrics software (Qualtrics version 9, Provo, UT). Survey data were processed and analysed using the R environment (R Development Core Team, 2006).


\subsubsection{Measures}

\myparagraph{Surveys}
Surveys were administered at three time points: 1) one day before the experiment (Baseline), 2) immediately before the experiment after receiving the experimental prime (Pre-Experiment), and 3) once immediately following the completion of the experiment (Post-Experiment)(see ~\ref{tab:surveyItemsByTime}).  Consistent with the previous study (Chapter 8), athletes responded to questions about 1) perceptions of components and overall individual and team performance in joint action, 2) feelings associated with ``team click'' in joint action, and feelings of social bonding and group membership.  In addition, athletes responded to survey items designed to measure possible moderators of the relationship between joint action and social bonding, namely: perceptions of arousal, fatigue, injury status, and personality type.

At Baseline, athletes were asked about their impressions of recent individual performance and the performance of their province team as a whole.  Survey items included questions relating to specific components of on-field performance (e.g., team components: Attack, defence, onfield communication, and support play; individual components: Passing technique, one-on-one tackling, effectiveness in contact areas) as well as items relating to overall impressions of performance, for example: ``How well do you feel your team has been performing in training and competition over the past month?'' (100 point scale, 0 = ``Extremely bad'', 100 = ``Extremely good'').  Athletes also responded to questions about feelings of team click and social bonding with their team as a whole. In addition, the Baseline survey also included items concerning basic personal information, current injury status, subjective and objective measures of tehcnical competence, and personality type.
For a full explanation of survey items measured at Baseline, see Chapter 6 (Introduction to Part B) and Appendix ~\ref{} Section ~\ref{}.

At time 2, immediately prior to the experiment (Pre-Experiment), athletes were asked questions about feelings and expectations concerning their individual performance and the performance of their specific training group in the impending training drill.
For example,  athletes were asked ``How do you feel \textit{right now} about your individual performance (100 point scale, 0 = ``Extremely bad'', 100 = ``Extremely good'')''.  Athletes were also asked a series of questions about feelings of team click and social bonding to their specific training group. For team click, for example, athletes were asked questions like: ``How do you feel the tacit understanding is between the training group today?'' (100 point scale, 0 = ``Extremely bad'', 100 = ``Extremely good'').  For social bonding, athletes were asked questions like: ``How emotionally supportive does your training group feel right now?'' (100 point scale, 0 = ``Extremely weak'', 100 = ``Extremely strong'').
For a full explanation of survey items measured at Pre-Experiment, see Appendix ~\ref{} Section ~\ref{}.

At time 3, immediately after the completion of the experiment (Post-Experiment), athletes completed questions concerning their impression of their own performance and the performance of their training group in the training drill, relative to their prior expectations.  Athletes were also asked about their feelings of team click and social bonding to the training group as well as the provincial team as a whole (team-focussed questons mirrored the survey items that were asked one day earlier at Baseline).  For a full explanation of Post-Experiment survey items, see Appendix ~\ref{} Section ~\ref{}.

Surveys were generated in English by the researcher using Qualtrics software (Qualtrics version 9, Provo, UT). Surveys were translated into modern Chinese and back translated by two independent native Chinese speaking translators from Beijing Sports University to verify accuracy.  Athletes completed the modern Chinese version of each survey using WeChat on their personal mobile devices connected remotely to the internet.


<<surveyMeasureSummaryTable, eval=T, echo=F>>=
  #create all columns:
  Items <- c("Performance(Team)","TeamClick(Team)", "SocialBonding(Team)",
                "Performance(Group)", "TeamClick(Group)", "SocialBonding(Group)",
                    "Performance(Ind)", "Arousal", "Exertion")
  Baseline <- c("*","*","*","","","","*","","")
  Pre <- c("","","","*","*","*","*","*","")
  Post <- c("","*","*","*","*","*","*","*","*")

  surveyMeasureSummary <- data.frame(Items, Baseline, Pre, Post, stringsAsFactors = FALSE)

  summaryTable <- xtable(surveyMeasureSummary,
                                caption = "Survey items measured at each time point",
                                label = "tab:surveyItemsByTime")

  align(summaryTable) <- "llccc"
  print(summaryTable, file="surveyItemsByTime.tex")


t.test(tlc$age~tlc$condition)
hist(tlc$age[tlc$condition == "high"])
hist(tlc$age[tlc$condition == "low"])
summary(tlc$age)

@


\subsubsection{Video analysis of training group performance in training drill}
In order to produce quantitative measures of interpersonal coordination between co-actors, athletes’ motion was captured by a single digital video camera (Sony FDR-AX700 4K HDR Camcorder) mounted on a 1.2m high tripod. Digital video images of action were acquired by a computer, using a USB2.0 cable, and files were saved on an encrypted external hard disk in .AVI format. For image treatment, TACTO 8.0 software was used for digitizing at 25 frames per second.

Video footage from all 8 experiment sessions was analysed by an hypothesis blind research assistant.  Each experimental trial of the Invasion Drill (16 in total) was coded according to the quality of performance relative to the primary (attacking) goal of the drill, i.e., scoring a try by carrying the ball over the try line.  A maximum value of 6 was awarded to a ``clear try'' (trials in which a clear unobstructed try was scored by the attacking sub-unit); 5 to a ``rough try'' (the ball-carrier crossed the try-line following some minimal level of physical contact or obstruction from the defence that did not halt the momentum of the attacking phase); 4 to an ``Obstructed try'' (a trial in which a try is scored, but the momentum of the attacking sub-unit was clearly interrupted); 3 to a ``no try - defence''  (a trial in which a ball carrier is completely obstructed by a defender, and the trial is unsuccessful largely due to the effecticeness of the defence); 2 to a ``no try - defence forced error'' (unsuccessful trial due to a combination of the defence and error in attack); 1 to a ``no try - unforced error'' (a failed trial due to an unforced error in attack).
For each experiment session, an average performance outcome (``Trial Outcome Average'') and the standard deviation of this outcome (``Trial Outcome SD'') was calculated in order to capture the central tendency and variability of performance for each training group.

\subsection{Procedure}
Permission to run the study was sought from the head coach of each of the four teams (Beijing men's, Beijing women's, Shandong men's, Shandong women's).  These coaches nominated athletes who were fit and able to complete the session without compromising their existing training schedules.  Athletes were randomly assigned to one of two conditions, and then athletes in each experimental group were subsequently adjusted subsequently so that each condition was matched as much as possible according to average training age. Once athletes were assigned to an experimental group, they were then added to a WeChat group populated by other training group members and the researcher.

\subsubsection{Cover Story}
Athletes were notified (first via WeChat and then in a team meeting) that they were participating in a trial of a number of different rugby training drills selected from a recent report by World Rugby concerning training methods for rugby sevens.  Athletes were told that the training drills had been previously rated by a selection of international level coaches and players from all over the world (including Asia and China).  Athletes were informed that the purpose of the exercise was for me to assess the ratings provided by World Rugby by replicating these drills with more rugby athletes in China.  Athletes were told that survey measures and video footage would be collected, which would be later analysed to assess individual performance of athletes in each training drill.  It was also explained to athletes that there would be a second round of drills also requiring groups of eight athletes, but the makeup of these groups may reshuffle depending on athletes preferences.  This detail allowed for the includion of a post-experiment bonding measure, in which athletes were asked to what extent they wished to continue to train with the same 8-athlete team in a subsequent round of drills.

Approximately 24 hours before the experiment session, athletes were instructed to complete the baseline survey by opening a link provided in the WeChat group.  This survey included written consent for the study. Approximately 1 hour before the experiment was due to take place, athletes were administered with an experimental prime via WeChat.  In the ``high difficulty'' condition, athletes were primed to believe that they were about to participate in a very difficult training drill (on the upper end of their individual and group technical abilities), whereas athletes in the ``low difficulty'' condition were primed to believe that they were about to participate in a relatively easy training drill well within their technical abilities (see APPENDIX for full script). All athletes were lead to believe that athletes in the other experiemntal groups were performing different drills to their assigned drill. In reality, the training drill for each condition was identical, the only thing that varied was the pre-experiment prime.

Once athletes were assembled at the designated training field, I verbally re-administered the same prime that had been sent to athletes via WeChat an hour earlier.  In addition, athletes were told in more detail about the requirements of the Invasion Drill (see APPENDIX for full details).  Specifically, athletes were told that their performance in the experiment would be assessed based on subsequent video analysis.  I told athletes that they would be assessed based on their performance in attack, defense, and their ability to coordinate attack and defense with others.  Athletes were provided with no other explicit information regarding performance goals, besides completing the experimental drill to the best of their ability within the rules of rugby.

Athletes were then administered with the time 2 survey (Pre-experiment), which took approximately 3-5 minutes to complete.  After every athlete had finished the survey, athletes participated in a standard warm up routine lasting approximately 10 minutes, including slow jogging and dynamic stretching.  Athletes were instructed not to use the rugby ball during this period, which served to reduce the amount of incidental coordination and interaction between participants prior to the start of the experiment trials.  Once athletes had completed the warm up, the researcher assembled the group within the training drill area.  One athlete was randomly assigned to stand at each of 8 available plastic markers (6 in the case of the modified drills).  In this position, athletes were told once more about the structure and procedure for the training drill, in particular the way in which athletes were expected to rotate clockwise after every trial of the drill so that athletes did not habituate to certain positions or sub-units in the drill.

To begin the drill, the ball-carrier at the front and centre of the attack sub-group was instructed to tap the ball with his / her foot, before initiating the attacking sub-phase by advancing forward towards the defence sub-units.  In the case that the ball was immediately fumbled during the initiation of the trial, the training group was instructed to restart that trial and the trial in which the mistake was made was not counted.  Following a block of 4 practice trials, athletes were told by the researcher that the formal test was beginning.  The group of athletes then completed 16 trials of the drill, which allowed each athlete to complete four trials of attack and four trials of defence, in different positions.  Following completion of all 16 test trials, athletes were assembled by the researcher and thanked for their participation, before being sent to the sideline of the training field to complete the final post-experiment survey using their mobile devices.  Following the completion of this final survey, athletes were told that they would be informed within two days about the next experiment trial (in fact, no more experiments were taking place).

\myparagraph{Video Analysis Procedure}
The digital camera and tripod were positioned on a platform 2m above the level of the playing field, approximately 10-15m from the bottom try-line corner of the Invasion Drill perimeter (see figure ~\ref{fig:invasionDrill}).  The experimenter began video recording before the athletes arrived, and ceased recording after all athletes had left the training field following the experiment.  Digital video images of action were acquired by a computer, using a USB2.0 cable, and files were saved on an encrypted external hard disk in .AVI format.

%For image treatment, TACTO 8.0 software was used for digitizing at 25 frames per second.
%The procedure is how the study was carried out. It often works well to describe the procedure in terms of what the participants did rather than what the researchers did. For example, the participants gave their informed consent, read a set of instructions, completed a block of four practice trials, completed a block of 20 test trials, completed two questionnaires, and were debriefed and excused.





<<excludePoorPerformance, echo=F,eval=T>>=

#twcEx <- subset(twc, successTotals > 4)
#tlcEx <- subset(tlc, successTotals > 4)



@










%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%RESULTS%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%SECTION%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Results}
A total of \Sexpr{length(unique(twc$englishName))} athletes participated in \Sexpr{length(unique(twc$sessionNumber))} experimental sessions. In one session (Shandong men's high difficulty condition) a research assistant stood in as a dummy participant for an athlete could not participate due to injury.  In the two sessions with Beijing women's team, due to failure of athletes to take part due to injury (3) or illness (2), the training drill was modified to a ``3 on 2 + 1'' drill, requiring only six athletes to complete instead of eight. In one of these experimental sessions, a female dummy participant was also required to fill in to make up a total of 6 athletes for the modified drill.  In both cases, dummy participants were competent ex-athletes who were naive to the predictions of the study.  Dummy participants did not participate in the survey responses before or after the session. Survey and video data of the remaining 58 participants was analysed.






\subsection{Descriptive Statistics}

\subsubsection{Participants}

<<dfAthleteSummary, echo=F,eval=T>>=
  twcAthleteInfo <- subset(twc, select = c(age, sex, condition, team, startingReserve,
                                      trainingAge, yearsTeam, athleteStatus, teamStatus))
  ##subset a master df to create a table strata by condition (Overall, High, Low)
  #df1:
  dfAthleteSummary <- twcAthleteInfo
  #df2:
  dfAthleteSummaryOverall <- dfAthleteSummary
  library(dplyr)
  dfAthleteSummaryOverall <- dfAthleteSummaryOverall %>%
                                mutate(condition = dplyr::recode(condition, "high" = "Overall"),
                                       condition = dplyr::recode(condition, "low" = "Overall")
                                       )

  dfAthleteSummary <- bind_rows(dfAthleteSummary, dfAthleteSummaryOverall)
  summary(dfAthleteSummary)

  dfAthleteSummary$condition <- factor(dfAthleteSummary$condition,
                                        levels = c("Overall", "high", "low"), ordered = is.ordered(dfAthleteSummary$condition))


  ## rename values for factors:
  dfAthleteSummary$sex <- ifelse(!is.na(dfAthleteSummary$sex) & dfAthleteSummary$sex == 0,
                                      "male",
                                      ifelse(!is.na(dfAthleteSummary$sex) & dfAthleteSummary$sex == 1, "female", NA))


  dfAthleteSummary$athleteStatus <- ifelse(!is.na(dfAthleteSummary$athleteStatus) &
                                      dfAthleteSummary$athleteStatus == 3, "Master",
                                        ifelse(!is.na(dfAthleteSummary$athleteStatus) & dfAthleteSummary$athleteStatus == 2, "1st Level",
                                          ifelse(!is.na(dfAthleteSummary$athleteStatus) & dfAthleteSummary$athleteStatus == 1, "2nd Level", NA)))

  dfAthleteSummary$teamStatus <- ifelse(!is.na(dfAthleteSummary$teamStatus) &
                                      dfAthleteSummary$teamStatus == 5, "Full time employee",
                                        ifelse(!is.na(dfAthleteSummary$teamStatus) & dfAthleteSummary$teamStatus == 4, "Full time contract",
                                          ifelse(!is.na(dfAthleteSummary$teamStatus) & dfAthleteSummary$teamStatus == 3, "Training contract",
                                          ifelse(!is.na(dfAthleteSummary$teamStatus) & dfAthleteSummary$teamStatus == 2, "Student contract",
                                          ifelse(!is.na(dfAthleteSummary$teamStatus) & dfAthleteSummary$teamStatus == 1, "Trial",
                                           NA)))))

  dfAthleteSummary$team <- ifelse(!is.na(dfAthleteSummary$team) & dfAthleteSummary$team ==
                                          "bjm","Beijing Men", ifelse(!is.na(dfAthleteSummary$team) & dfAthleteSummary$team == "bjw", "Beijing Women", ifelse(!is.na(dfAthleteSummary$team) & dfAthleteSummary$team == "sdm", "Shandong Men", ifelse(!is.na(dfAthleteSummary$team) & dfAthleteSummary$team == "sdw", "Shandong Women", NA))))

  ##rename columns for tables:
  dfAthleteSummary <- dplyr::rename(dfAthleteSummary, Position = startingReserve, TrainingAge = trainingAge, YearsInTeam = yearsTeam, AthleteLevel = athleteStatus, ContractStatus = teamStatus, Team = team, Condition = condition, Sex = sex, Age = age)



library(table)
  ## create a variable list which we want in table one
  listVars <- c("Age", "Sex", "Team", "Position",  "TrainingAge" , "YearsInTeam", "AthleteLevel", "ContractStatus")

  ## define categorical variables
  catVars <- c("Sex", "Condition", "AthleteLevel", "Position", "ContractStatus", "Team")


  ## Create overall table:
  table1 <- CreateTableOne(vars = listVars,
                           data = dfAthleteSummary,
                           strata = "Condition",
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  table1_overall <- print(table1,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  library(xtable)
  print(xtable(table1_overall, type="latex",
                      caption = "Overview of experiment sample, overall and by condition (low and high difficulty).",
                      label = "tab:athleteDescriptivesTrainingOverall"),
                      file="athleteDescriptivesTrainingOverall.tex")
@

\input{/Users/jacob1/Documents/2017/Research/DPhil/Dissertation/finalDocuments/jointActionSocialBonding/images/athleteDescriptivesTrainingOverall.tex}

<<manipulationChecksPrep1, echo=F,eval=T>>=
  #condition differences in:
  # 1. groupConfidentTechnicalChallenges,
  # 2. indConfidenceChallenges,
  # 3. arousal
  #subset df according to condition:
  low <- subset(twc, condition == "low")
  high <- subset(twc, condition == "high")
@

<<standardise groupPerformance_3, eval=T, echo=F>>=
  #standardise groupPerformance_3:
  twc$groupPerformance_3Norm <- scale(twc$groupPerformance_3)
  twc$indPerformance_3Norm <- scale(twc$indPerformance_3)
@



The attributes of the overall sample of athletes are displayed in Table ~\ref{tab:athleteDescriptivesTrainingOverall}. The average training age of athletes was \Sexpr{mean(twc$trainingAge,na.rm=T)} years (\Sexpr{sd(twc$trainingAge,na.rm=T)}), with athletes having spent on average over \Sexpr{mean(twc$years,na.rm=T)} years in the team.
\Sexpr{round(length(which(twc$teamStatus == 5))/length(unique(twc$englishName))*100, digits = 0)}\% of the sample were full-time employees of their provincial team, with the rest either being employed on a full-time (but fixed term) contract
(\Sexpr{round(length(which(twc$teamStatus == 4))/length(unique(twc$englishName))*100, digits = 2)}\%)), a ``student contract'' ((\Sexpr{round(length(which(twc$teamStatus == 3))/length(unique(twc$englishName))*100, digits = 2)}\%))), a short term training contract
((\Sexpr{round(length(which(twc$teamStatus == 2))/length(unique(twc$englishName))*100, digits = 2)}\%))), or on a short-term trial basis ((\Sexpr{round(length(which(twc$teamStatus == 1))/length(unique(twc$englishName))*100, digits = 2)}\%))).
 \Sexpr{length(which(twc$startingReserve == "Starting Team"))} of \Sexpr{length(unique(twc$englishName))} (\Sexpr{round(length(which(twc$startingReserve == "Starting Team"))/length(unique(twc$englishName))*100, digits = 0)}\%) of athletes declared that there were in the starting team of their respective provincial teams.
Attributes of athletes in the high and low difficulty conditions were evenly matched (see Table ~\ref{tab:athleteDescriptivesTrainingOverall}), with only a marginally significant difference in average age between conditions (high difficulty condition = \Sexpr{mean(high$age,na.rm=T)}(\Sexpr{sd(high$age,na.rm=T)}), low difficulty condition = \Sexpr{mean(low$age,na.rm=T)}(\Sexpr{sd(low$age,na.rm=T)}).

\subsubsection{Survey Responses}

Athlete responses to survey items were collated according to main variables of interest, particularly perceptions of individual and team performance in joint action, social variables relating to team click, social bonding, and moderator variables related to technical competence, arousal, exertion, and personality. In general, the central tendency of all survey items was between .5 to 1.5 standard deviations above the mid-point of the scale, with almost all survey item distributions exhibiting low to moderate negative skew.  Average athlete perceptions of individual (Appendix Tables ~\ref{tab:indPerfTimeLowTraining} and ~\ref{tab:indPerfTimeHighTraining}), group (Appendix Tables ~\ref{tab:groupPerfTimeLowTraining} and ~\ref{tab:groupPerfTimeHighTraining}), and team (measured at Baseline only, see Appendix Table ~\ref{tab:teamPerfTimeBaselineTraining}) performance ranged from a low of 58.31(17.71) for perceptions of individual performance relative to prior expectations (measured post-Experiment) to a high of 78.62 (12.75) for athlete confidence in group ability to meet the technical challenges of the drill, measured pre-Experiment.  Athletes were on average more critical in regards to perceptions of individual performance than they were of group and team performance, and were generally more critical of individual and group performance in the post-Experiment survey than they were in the Baseline and pre-Experiment surveys (see Appendix Tables ~\ref{tab:indPerfTimeLowTraining}\nobreakdash~\ref{tab:teamPerfTimeBaselineTraining}).

Central tendencies of variables measuring athletes' perceptions of group click and social bonding were also well above the mid-point of their respective scales, ranging from a low of 68.34 (SD = 14.69) for feelings of unspoken understanding measured post-Experiment in the low difficulty condition, to a high of 90.21 (SD = 9.33) for feelings of shared goal with the training group measured pre-Experiemnt in the low difficulty condition (see Appendix Tables ~\ref{tab:groupClickTimeHighTraining}\nobreakdash--\ref{tab:teamBondingTimeHighTraining}). Measures relating to Team Click and Social bonding also appeared to decrease in the post-Experiment survey relative to the pre-Experiment and Baseline surveys.  Objective measures of training group performance derived from video footage appeared to be consistent across experiment conditions (see Appendix Table ~\ref{tab:objectiveOutcomeCondition}).  For a description of the remaining moderator variables, see Appendix section ~\ref{}.

%%GROUP PERFORMANCE:
<<descriptivesGroupPerformance, echo=F,eval=T>>=
library(xtable)
  ##subset data for renaming
  tlcGroupPerformance <- subset(tlc, select = c(englishName, condition, sex, time, team,
                                  groupPerformance, groupConfidentTechnicalChallenges, groupAttackingLine, groupDefensiveLine,  groupOnfieldCommunication, groupSupportPlay))
  ## groupPerformance is only @ time = 3, and is in terms of expectations...rescale.
  tlcGroupPerformance$groupPerformanceExp <- tlcGroupPerformance$groupPerformance
  #tlcGroupPerformance$groupPerformanceExp[tlcGroupPerformance$time == 1] <- NA
  #tlcGroupPerformance$groupPerformanceExp[tlcIndPerformance$time == 2] <- NA
  #tlcGroupPerformance$groupPerformance[tlcGroupPerformance$time == 3] <- NA
  #rescale groupPerformaneExp to (0,100)
  library(scales)
  tlcGroupPerformance$groupPerformanceExp[tlcGroupPerformance$time == 3] <- scales::rescale(tlcGroupPerformance$groupPerformanceExp[tlcGroupPerformance$time == 3], to = c(0, 100))



  ## rename values for factors:
  tlcGroupPerformance$sex <- ifelse(!is.na(tlcGroupPerformance$sex) & tlcGroupPerformance$sex == 0, "male",
                                    ifelse(!is.na(tlcGroupPerformance$sex) & tlcGroupPerformance$sex == 1, "female", NA))

  tlcGroupPerformance$time <- ifelse(!is.na(tlcGroupPerformance$time) &
                                    tlcGroupPerformance$time == 3, "Post",
                                  ifelse(!is.na(tlcGroupPerformance$time) &     tlcGroupPerformance$time == 2, "Pre",
                                  ifelse(!is.na(tlcGroupPerformance$time) & tlcGroupPerformance$time == 1, "Baseline", NA)))
  tlcGroupPerformance$time <- factor(tlcGroupPerformance$time, levels = c("Baseline", "Pre",
                                    "Post"), ordered = is.ordered(tlcGroupPerformance$time))

  ##rename columns for tables:
  tlcGroupPerformance <- dplyr::rename(tlcGroupPerformance, Name = englishName, Sex = sex,
                                  Team = team, Condition = condition, Time = time, PerformanceVsExpectations = groupPerformanceExp, ConfidenceInGroupAbility = groupConfidentTechnicalChallenges, GroupAttack = groupAttackingLine, GroupDefence = groupDefensiveLine, GroupCommunication = groupOnfieldCommunication, GroupSupportPlay = groupSupportPlay)

  # create high and low condition dfs:
  tlcGroupPerformanceHigh <- subset(tlcGroupPerformance, Condition == "high")

  tlcGroupPerformanceLow <- subset(tlcGroupPerformance, Condition == "low")

  ## create a variable list which we want in table one
  listVars <- c("GroupPerformVsExpected", "ConfidenceInGroupAbility", "GroupAttack",
                "GroupDefence", "GroupCommunication", "GroupSupportPlay")

  ## define categorical variables
  catVars <- c("Sex", "Condition", "Time")

  ## create table one (high difficulty condition)
  tableGroupPerfHigh_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcGroupPerformanceHigh,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableGroupPerformHighTime <- print(tableGroupPerfHigh_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableGroupPerformHighTime, type="latex",
               caption = "Athlete perceptions of \n group performance (high difficulty condition)"),
              file="groupPerfTimeHighTraining.tex")


  ## create table one (low difficulty condition)
  tableGroupPerfLow_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcGroupPerformanceLow,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableGroupPerformLowTime <- print(tableGroupPerfLow_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableGroupPerformLowTime, type="latex",
               caption = "Athlete perceptions of \n group performance (low difficulty condition)"),
                file="groupPerfTimeLowTraining.tex")
@
%%IND PERFORMANCE
<<descriptivesIndividualPerformance, echo=F,eval=T>>=

  ##subset data for renaming
  tlcIndPerformance <- subset(tlc, select = c(englishName, condition, sex, time, team,
                                              indPerformance, indConfidenceChallenges, indDefense, passingTechnique,
                                              supportPlay, decisionMaking, effectivenessInContact))
  ## Change indPerformance @ time = 3 to another variable, and delete values at time = 3
  tlcIndPerformance$indPerformanceExp <- tlcIndPerformance$indPerformance
  tlcIndPerformance$indPerformanceExp[tlcIndPerformance$time == 1] <- NA
  tlcIndPerformance$indPerformanceExp[tlcIndPerformance$time == 2] <- NA
  tlcIndPerformance$indPerformance[tlcIndPerformance$time == 3] <- NA
  #rescale indPerformaneExp to (0,100)
  library(scales)
  tlcIndPerformance$indPerformanceExp[tlcIndPerformance$time == 3] <- scales::rescale(tlcIndPerformance$indPerformanceExp[tlcIndPerformance$time == 3], to = c(0, 100))

  ## rename values for factors:
  tlcIndPerformance$sex <- ifelse(!is.na(tlcIndPerformance$sex) &
                                  tlcIndPerformance$sex == 0, "male",
                                  ifelse(!is.na(tlcIndPerformance$sex) & tlcIndPerformance$sex == 1, "female", NA))

  tlcIndPerformance$time <- ifelse(!is.na(tlcIndPerformance$time) &
                                    tlcIndPerformance$time == 3, "Post",
                                  ifelse(!is.na(tlcIndPerformance$time) &     tlcIndPerformance$time == 2, "Pre",
                                  ifelse(!is.na(tlcIndPerformance$time) & tlcIndPerformance$time == 1, "Baseline", NA)))
  tlcIndPerformance$time <- factor(tlcIndPerformance$time, levels = c("Baseline", "Pre",
                                    "Post"), ordered = is.ordered(tlcIndPerformance$time))

  ##rename columns for tables:
  tlcIndPerformance <- dplyr::rename(tlcIndPerformance, Name = englishName, Sex = sex, Team = team,
                                  Condition = condition, Time = time, OverallPerformance = indPerformance,
                                  ConfidenceInAbility = indConfidenceChallenges, PerformanceVsExpectations = indPerformanceExp,
                                  Defence = indDefense, Passing = passingTechnique, SupportPlay = supportPlay,
                                  DecisionMaking = decisionMaking, Contact = effectivenessInContact)

  # create high and low condition dfs:
  tlcIndPerformanceHigh <- subset(tlcIndPerformance, Condition == "high")

  tlcIndPerformanceLow <- subset(tlcIndPerformance, Condition == "low")

  ## create a variable list which we want in table one
  listVars <- c("PerformanceVsExpectations", "ConfidenceInAbility", "Defence",
                "Passing", "SupportPlay", "DecisionMaking", "OverallPerformance")


  ## define categorical variables
  catVars <- c("Sex", "Condition", "Time")

  ## create table one (high difficulty condition)
  tableIndPerfHigh_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcIndPerformanceHigh,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableIndPerformHighTime <- print(tableIndPerfHigh_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableIndPerformHighTime, type="latex",
                        label = "tab:indPerfTimeHighTraining",
                        caption = "Athlete perceptions of \n individual performance (high difficulty condition)"),
                        file="indPerfTimeHighTraining.tex")


  ## create table one (low difficulty condition)
  tableIndPerfLow_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcIndPerformanceLow,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableIndPerformLowTime <- print(tableIndPerfLow_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableIndPerformLowTime, type="latex",
                            label = "tab:indPerfTimeHighTraining",
                            caption = "Athlete perceptions of \n individual performance (low difficulty condition)"),
                            file="indPerfTimeLowTraining.tex")
@
%GROUP CLICK:
<<descriptivesGroupClick, echo=F,eval=T>>=
  ##subset data for renaming
  tlcGroupClick <- subset(tlc, select = c(englishName, condition, sex, time, team,
                                  groupClickPictorial, groupUnspokenUnderstanding, groupGeneralAtmosphere,
                                  groupAbilitiesExtended, groupReliabilityForOthers,
                                  groupReliabilityOfOthers))
  ## groupClick is only @ time = 3, and is in terms of expectations...rescale.
  #tlcGroupClick$groupClick <- tlcGroupClick$groupClick
  #tlcGroupPerformance$groupPerformanceExp[tlcGroupPerformance$time == 1] <- NA
  #tlcGroupPerformance$groupPerformanceExp[tlcIndPerformance$time == 2] <- NA
  #tlcGroupPerformance$groupPerformance[tlcGroupPerformance$time == 3] <- NA
  #rescale groupPerformaneExp to (0,100)
  #library(scales)
  #tlcGroupPerformance$groupPerformanceExp[tlcGroupPerformance$time == 3] <- rescale(tlcGroupPerformance$groupPerformanceExp[tlcGroupPerformance$time == 3], to = c(0, 100), from = c(-50, 50))


  ## rename values for factors:
  tlcGroupClick$sex <- ifelse(!is.na(tlcGroupClick$sex) &
                                  tlcGroupClick$sex == 0, "male", ifelse(!is.na(tlcGroupClick$sex) & tlcGroupClick$sex == 1, "female", NA))

  tlcGroupClick$time <- ifelse(!is.na(tlcGroupClick$time) &
                                    tlcGroupClick$time == 3, "Post",
                                  ifelse(!is.na(tlcGroupClick$time) &     tlcGroupClick$time == 2, "Pre",
                                  ifelse(!is.na(tlcGroupClick$time) & tlcGroupClick$time == 1, "Baseline", NA)))
  tlcGroupClick$time <- factor(tlcGroupClick$time, levels = c("Baseline", "Pre",
                                    "Post"), ordered = is.ordered(tlcGroupClick$time))

  ##rename columns for tables:
  library(dplyr)
  tlcGroupClick <- dplyr::rename(tlcGroupClick, Name = englishName, Sex = sex,
                                  Team = team, Condition = condition, Time = time,
                                  ClickPictorial = groupClickPictorial,
                                  UnspokenUnderstanding = groupUnspokenUnderstanding,
                                  GeneralAtmosphere = groupGeneralAtmosphere,
                                  AbilitiesExtended = groupAbilitiesExtended,
                                  ReliabilityForOthers = groupReliabilityForOthers,
                                  ReliabilityOfOthers = groupReliabilityOfOthers)


  # create high and low condition dfs:
  tlcGroupClickHigh <- subset(tlcGroupClick, Condition == "high")

  tlcGroupClickLow <- subset(tlcGroupClick, Condition == "low")

  ## create a variable list which we want in table one
  listVars <- c("ClickPictorial", "UnspokenUnderstanding", "GeneralAtmosphere",
                "AbilitiesExtended", "ReliabilityForOthers", "ReliabilityOfOthers")


  ## define categorical variables
  catVars <- c("Sex", "Condition", "Time")

  ## create table one (high difficulty condition)
  tableGroupClickHigh_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcGroupClickHigh,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableGroupClickHighTime <- print(tableGroupClickHigh_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableGroupClickHighTime, type= "latex",
               caption = "Athlete perceptions of \n group click (high difficulty condition)"), file="groupClickTimeHighTraining.tex")


  ## create table one (low difficulty condition)
  tableGroupClickLow_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcGroupClickLow,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableGroupClickLowTime <- print(tableGroupClickLow_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableGroupClickLowTime, type="latex",
               caption = "Athlete perceptions of \n group click (low difficulty condition)"), file="groupClickTimeLowTraining.tex")
@
%GROUP BONDING:
<<descriptivesGroupBonding, echo=F,eval=T>>=
  ##subset data for renaming
  tlcGroupBonding <- subset(tlc, select = c(englishName, condition, sex, time, team,
                                            groupEmotionalSupport, groupSharedGoal,
                                            groupFusionPictorial, groupStayChange))


  ## Need to reverse group Stay Change and locate it correctly at Post-Tournament:
  ## First locate @ t = 3:
  tlcGroupBonding$groupStayChange[tlc$time == 3] <- tlcGroupBonding$groupStayChange[tlc$time == 1]
  tlcGroupBonding$groupStayChange[tlc$time == 1] <- NA
  ## Now reverse the scores, so that higher values are more pro-group:
  tlcGroupBonding$groupStayChangeRev <- 100 - tlcGroupBonding$groupStayChange

  ## rename values for factors:
  tlcGroupBonding$sex <- ifelse(!is.na(tlcGroupBonding$sex) &
                                  tlcGroupBonding$sex == 0, "male",
                                  ifelse(!is.na(tlcGroupBonding$sex) & tlcGroupBonding$sex == 1, "female", NA))

  tlcGroupBonding$time <- ifelse(!is.na(tlcGroupBonding$time) &
                                    tlcGroupBonding$time == 3, "Post",
                                  ifelse(!is.na(tlcGroupBonding$time) & tlcGroupBonding$time == 2, "Pre",
                                  ifelse(!is.na(tlcGroupBonding$time) & tlcGroupBonding$time == 1, "Baseline", NA)))
  tlcGroupBonding$time <- factor(tlcGroupBonding$time, levels = c("Baseline", "Pre",
                                    "Post"), ordered = is.ordered(tlcGroupBonding$time))

  ##rename columns for tables:
  tlcGroupBonding <- dplyr::rename(tlcGroupBonding, Name = englishName, Sex = sex,
                                  Team = team, Condition = condition, Time = time,
                                  EmotionalSupport = groupEmotionalSupport, SharedGoal = groupSharedGoal,
                                  FusionPictorial = groupFusionPictorial,
                                  StayOrChange = groupStayChangeRev)

  # create high and low condition dfs:
  tlcGroupBondingHigh <- subset(tlcGroupBonding, Condition == "high")

  tlcGroupBondingLow <- subset(tlcGroupBonding, Condition == "low")

  ## create a variable list which we want in table one
  listVars <- c("EmotionalSupport", "SharedGoal", "FusionPictorial", "StayOrChange")


  ## define categorical variables
  catVars <- c("Sex", "Condition", "Time")

  ## create table one (high difficulty condition)
  tableGroupBondingHigh_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcGroupBondingHigh,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableGroupBondingHighTime <- print(tableGroupBondingHigh_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableGroupBondingHighTime, type= "latex",
               caption = "Athlete perceptions of \n group bonding (high difficulty condition)"),
               file="groupBondingTimeHighTraining.tex")


  ## create table one (low difficulty condition)
  tableGroupBondingLow_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcGroupBondingLow,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableGroupBondingLowTime <- print(tableGroupBondingLow_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableGroupBondingLowTime, type="latex",
                caption = "Athlete perceptions of \n group bonding (low difficulty condition)"),
                file="groupBondingTimeLowTraining.tex")
@
%TEAM BONDING
<<descriptivesTeamBonding, echo=F,eval=T>>=
  ##subset data for renaming
  tlcTeamBonding <- subset(tlc, select = c(englishName, condition, sex, time, team,
                                emotionalSupport, sharedGoal, fusionVerbal, groupId,
                                fusionPictorialTeam, fusionPictorialFamily, fusionPictorialCountry,
                                rankTeam, rankFamily, rankCountry))


  ## Need to reverse rank scores:
  tlcTeamBonding$rankTeamRev <- 3 - tlcTeamBonding$rankTeam
  tlcTeamBonding$rankFamilyRev <- 3 - tlcTeamBonding$rankFamily
  tlcTeamBonding$rankCountryRev <- 3 - tlcTeamBonding$rankCountry


  ## rename values for factors:
  tlcTeamBonding$sex <- ifelse(!is.na(tlcTeamBonding$sex) &
                                tlcTeamBonding$sex == 0, "male",
                                ifelse(!is.na(tlcTeamBonding$sex) & tlcTeamBonding$sex == 1, "female", NA))

  tlcTeamBonding$time <- ifelse(!is.na(tlcTeamBonding$time) &
                                  tlcTeamBonding$time == 3, "Post",
                                ifelse(!is.na(tlcTeamBonding$time) & tlcTeamBonding$time == 2, "Pre",
                                ifelse(!is.na(tlcTeamBonding$time) & tlcTeamBonding$time == 1, "Baseline", NA)))

  tlcTeamBonding$time <- factor(tlcTeamBonding$time, levels = c("Baseline", "Pre",
                                  "Post"), ordered = is.ordered(tlcTeamBonding$time))

  ##rename columns for tables:
  tlcTeamBonding <- dplyr::rename(tlcTeamBonding, Name = englishName, Sex = sex,
                                Team = team, Condition = condition, Time = time,
                                EmotionalSupport = emotionalSupport, SharedGoal = sharedGoal,
                                FusionVerbalTeam = fusionVerbal, GroupIdentification = groupId,
                                FusionPictorialTeam = fusionPictorialTeam,
                                FusionPictorialFamily = fusionPictorialFamily, FusionPictorialCountry = fusionPictorialCountry,
                                TeamRank = rankTeamRev, FamilyRank = rankFamilyRev, CountryRank = rankCountryRev)

  # create high and low condition dfs:
  tlcTeamBondingHigh <- subset(tlcTeamBonding, Condition == "high")

  tlcTeamBondingLow <- subset(tlcTeamBonding, Condition == "low")

  ## create a variable list which we want in table one
  listVars <- c("EmotionalSupport", "SharedGoal", "FusionVerbalTeam",
                "GroupIdentification", "FusionPictorialTeam", "FusionPictorialFamily",
                "FusionPictorialCountry", "TeamRank", "FamilyRank", "CountryRank")


  ## define categorical variables
  catVars <- c("Sex", "Condition", "Time")

  ## create table one (high difficulty condition)
  tableTeamBondingHigh_time <- CreateTableOne(vars = listVars,
                         strata = "Time",
                         data = tlcTeamBondingHigh,
                         factorVars = catVars,
                         test = F
                         )

  ## create table which is printable
  tableTeamBondingHighTime <- print(tableTeamBondingHigh_time,
                            quote = FALSE,
                            noSpaces = FALSE,
                            printToggle = FALSE
                            )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableTeamBondingHighTime, type= "latex",
                                         caption = "Athlete perceptions of \n team bonding (high difficulty condition)"),
                                         file="teamBondingTimeHighTraining.tex")


  ## create table one (low difficulty condition)
  tableTeamBondingLow_time <- CreateTableOne(vars = listVars,
                         strata = "Time",
                         data = tlcTeamBondingLow,
                         factorVars = catVars,
                         test = F
                         )

  ## create table which is printable
  tableTeamBondingLowTime <- print(tableTeamBondingLow_time,
                            quote = FALSE,
                            noSpaces = FALSE,
                            printToggle = FALSE
                            )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableTeamBondingLowTime,
               type="latex",
               caption = "Athlete perceptions of \n team bonding (low difficulty condition)"),
               file="teamBondingTimeLowTraining.tex")
@
%%IND PERFORMANCE SUBJECTIVE:
<<descriptivesIndividualPerformanceSubjective, echo=F,eval=T>>=

  tlcCompPerfSubj <- subset(tlc, select = c(englishName, condition, sex, time, team,
                                  indAbilityTeammates_1, indAbilityChina_1, indAbilityInternational_1,
                                  indPerformanceOnConfidence_1, indPerformanceOnMood_1))

  ## Need to remove values of confidence and mood from t 2 & 3:

  tlcCompPerfSubj$indPerformanceOnConfidence <- tlcCompPerfSubj$indPerformanceOnConfidence_1
  tlcCompPerfSubj$indPerformanceOnConfidence[tlcCompPerfSubj$time == 2] <- NA
  tlcCompPerfSubj$indPerformanceOnConfidence[tlcCompPerfSubj$time == 3] <- NA

  tlcCompPerfSubj$indPerformanceOnMood <- tlcCompPerfSubj$indPerformanceOnMood_1
  tlcCompPerfSubj$indPerformanceOnMood[tlcCompPerfSubj$time == 2] <- NA
  tlcCompPerfSubj$indPerformanceOnMood[tlcCompPerfSubj$time == 3] <- NA

  tlcCompPerfSubj$sex <- ifelse(!is.na(tlcCompPerfSubj$sex) &
                                  tlcCompPerfSubj$sex == 0, "male",
                                  ifelse(!is.na(tlcCompPerfSubj$sex) & tlcCompPerfSubj$sex == 1, "female", NA))

  tlcCompPerfSubj$time <- ifelse(!is.na(tlcCompPerfSubj$time) &
                                    tlcCompPerfSubj$time == 3, "Post",
                                  ifelse(!is.na(tlcCompPerfSubj$time) & tlcCompPerfSubj$time == 2, "Pre",
                                  ifelse(!is.na(tlcCompPerfSubj$time) & tlcCompPerfSubj$time == 1, "Baseline", NA)))
  tlcCompPerfSubj$time <- factor(tlcCompPerfSubj$time, levels = c("Baseline", "Pre",
                                    "Post"), ordered = is.ordered(tlcCompPerfSubj$time))

  ##rename columns for tables:
  #library(dplyr)
  tlcCompPerfSubj <- dplyr::rename(tlcCompPerfSubj, Name = englishName, Sex = sex, Team = team,
                                  Condition = condition, Time = time, CompetenceVsTeammates = indAbilityTeammates_1,
                                  CompetenceVsChinesePros = indAbilityChina_1,
                                  CompetenceVsInternationalPros = indAbilityInternational_1,
                                  PerfomanceImpactOnConfidence =  indPerformanceOnConfidence,
                                  PerformanceImpactOnMood = indPerformanceOnMood)


  ## create a variable list which we want in table one
  listVars <- c("CompetenceVsTeammates", "CompetenceVsChinesePros",
                  "CompetenceVsInternationalPros", "PerfomanceImpactOnConfidence", "PerformanceImpactOnMood")

  ## define categorical variables
  catVars <- c("Sex", "Condition", "Time")

  ## create table one (high difficulty condition)
  tableTlcCompPerfSubj <- CreateTableOne(vars = listVars,
                           strata = "Condition",
                           data = tlcCompPerfSubj,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableTlcCompPerfSubj.condition <- print(tableTlcCompPerfSubj,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableTlcCompPerfSubj.condition, type="latex",
                            label = "tab:indPerfTimeHighTraining",
                            caption = "Athlete subjective perceptions of \n individual technical competence by condition"),
                            file="compPerfSubjTraining.tex")
@
%%OBJECTIVE OUTCOME:
<<descriptivesObjectiveOutcome, echo=F,eval=T>>=
  tlcObjOutcome <- subset(tlc, select = c(englishName, condition, sex, time, team,
                                  outcomeAvg, outcomeSd))


  ##rename columns for tables:
  #library(dplyr)
  tlcObjOutcome <- dplyr::rename(tlcObjOutcome, Name = englishName, Sex = sex, Team = team,
                                  Condition = condition, Time = time,
                                 AverageOutcome = fullOutcomeAvg,
                                 TrialOutcomeAvg = outcomeAvg,
                                 TrialOutcomeSD = outcomeSD)
  ## create a variable list which we want in table one
  listVars <- c("TrialOutcomeAvg", "TrialOutcomeAvg")

  ## define categorical variables
  catVars <- c("Sex", "Condition", "Time")

  ## create table one (high difficulty condition)
  tlcObjOutcome <- CreateTableOne(vars = listVars,
                         strata = "Condition",
                         data = tlcCompPerfSubj,
                         factorVars = catVars,
                         test = F
                         )

  ## create table which is printable
  tlcObjOutcome.condition <- print(tlcObjOutcome,
                            quote = FALSE,
                            noSpaces = FALSE,
                            printToggle = FALSE,
                            test = F,
                            )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tlcObjOutcome.condition, type="latex",
                          label = "tab:objectiveOutcomeCondition",
                          caption = "Average performance in experiment trials by condition"),
                          file= "objectiveOutcomeCondition.tex")
@
%TEAM DISCIPLINE:
<<descriptivesTeamDiscipline, echo=F,eval=T>>=
  ##subset data for renaming
  tlcTeamDiscipline <- subset(tlc, select = c(englishName, condition, sex, time, team,
                                  teamPunctuality, teamAttendanceMeals, teamGeneralConduct, teamCurfew))

  ## rename values for factors:
  tlcTeamDiscipline$sex <- ifelse(!is.na(tlcTeamDiscipline$sex) &
                                  tlcTeamDiscipline$sex == 0, "male",
                                  ifelse(!is.na(tlcTeamDiscipline$sex) & tlcTeamDiscipline$sex == 1, "female", NA))

  tlcTeamDiscipline$time <- ifelse(!is.na(tlcTeamDiscipline$time) &
                                    tlcTeamDiscipline$time == 3, "Post",
                                  ifelse(!is.na(tlcTeamDiscipline$time) & tlcTeamDiscipline$time == 2, "Pre",
                                  ifelse(!is.na(tlcTeamDiscipline$time) & tlcTeamDiscipline$time == 1, "Baseline", NA)))
  tlcTeamDiscipline$time <- factor(tlcTeamDiscipline$time, levels = c("Baseline", "Pre",
                                    "Post"), ordered = is.ordered(tlcTeamDiscipline$time))


  #teamPunctuality, teamAttendanceMeals, teamGeneralConduct, teamCurfew
  ##rename columns for tables:
  tlcTeamDiscipline <- dplyr::rename(tlcTeamDiscipline, Name = englishName, Sex = sex,
                                  Team = team, Condition = condition, Time = time,
                                  Punctuality = teamPunctuality, MealAttendance = teamAttendanceMeals,
                                  GeneralConduct = teamGeneralConduct, Curfew = teamCurfew)

  # create high and low condition dfs:
  tlcTeamDisciplineHigh <- subset(tlcTeamDiscipline, Condition == "high")

  tlcTeamDisciplineLow <- subset(tlcTeamDiscipline, Condition == "low")

  ## create a variable list which we want in table one
  listVars <- c("Punctuality", "MealAttendance", "GeneralConduct",
                  "Curfew")


  ## define categorical variables
  catVars <- c("Sex", "Condition", "Time")

  ## create table one (high difficulty condition)
  tableTeamDisciplineHigh_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcTeamDisciplineHigh,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableTeamDisciplineHighTime <- print(tableTeamDisciplineHigh_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableTeamDisciplineHighTime, type= "latex",
               caption = "Athlete perceptions of \n team discipline (high difficulty condition)"),
               file="teamDisciplineTimeHighTraining.tex")


  ## create table one (low difficulty condition)
  tableTeamDisciplineLow_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcTeamDisciplineLow,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableTeamDisciplineLowTime <- print(tableTeamDisciplineLow_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableTeamDisciplineLowTime, type="latex",
               caption = "Athlete perceptions of \n team discipine (low difficulty condition)"),
               file="teamDisciplineTimeLowTraining.tex")
@
%AROUSAL/EXERTION:
<<descriptivesArousalExertion, echo=F,eval=T>>=
  ## Reomve t1 and t2 scores from prpe and mental:
  tlc$prpe <- tlc$prpe_3
  tlc$prpe[tlc$time == 1] <- NA
  tlc$prpe[tlc$time == 2] <- NA
  tlc$mental <- tlc$mental_3
  tlc$mental[tlc$time == 1] <- NA
  tlc$mental[tlc$time == 2] <- NA

  tlcArousalExertion <- subset(tlc, select = c(englishName, age, sex, condition, team,
                                  time, aroused, excited, relaxed, fatigue, prpe, mental, injury))



  ## rename values for factors:
  tlcArousalExertion$sex <- ifelse(!is.na(tlcArousalExertion$sex) &
                                  tlcArousalExertion$sex == 0, "male",
                                  ifelse(!is.na(tlcArousalExertion$sex) & tlcArousalExertion$sex == 1,
                                         "female", NA))

  tlcArousalExertion$time <- ifelse(!is.na(tlcArousalExertion$time) &
                                    tlcArousalExertion$time == 3, "Post",
                                  ifelse(!is.na(tlcArousalExertion$time) & tlcArousalExertion$time == 2, "Pre",
                                  ifelse(!is.na(tlcArousalExertion$time) & tlcArousalExertion$time == 1, "Baseline", NA)))
  tlcArousalExertion$time <- factor(tlcArousalExertion$time, levels = c("Baseline", "Pre",
                                    "Post"), ordered = is.ordered(tlcArousalExertion$time))


  ##rename columns for tables:
  tlcArousalExertion <- dplyr::rename(tlcArousalExertion, Name = englishName, Sex = sex,
                                  Team = team, Condition = condition, Time = time,
                                  Aroused = aroused, Excited = excited, Relaxed = relaxed, Fatigue = fatigue,
                                  PhysicalExertion= prpe, MentalExertion = mental, InjuryStatus = injury)

  # create high and low condition dfs:
  tlcArousalExertionHigh <- subset(tlcArousalExertion, Condition == "high")

  tlcArousalExertionLow <- subset(tlcArousalExertion, Condition == "low")

  ## create a variable list which we want in table one
  listVars <- c("Aroused", "Excited", "Relaxed", "Fatigue",
                  "PhysicalExertion", "MentalExertion", "InjuryStatus")


  ## define categorical variables
  catVars <- c("Sex", "Condition", "Time")

  ## create table one (high difficulty condition)
  tableArousalExertionHigh_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcArousalExertionHigh,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableArousalExertionHighTime <- print(tableArousalExertionHigh_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableArousalExertionHighTime, type= "latex",
               caption = "Athlete arousal \n (high difficulty condition)"),
               file="arousalExertionTimeHighTraining.tex")


  ## create table one (low difficulty condition)
  tableArousalExertionLow_time <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcArousalExertionLow,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableArousalExertionLowTime <- print(tableArousalExertionLow_time,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableArousalExertionLowTime, type="latex",
               caption = "Athlete arousal and exertion \n (low difficulty condition)"),
               file="arousalExertionTimeLowTraining.tex")
@
%PERSONALITY:
<<descriptivesPersonality, echo=F,eval=T>>=
  tlcPersonality <- subset(tlc, select = c(englishName, condition, sex, time, team,
                                  tipiAgreeableness, tipiConscientiousness,
                                  tipiEmotionalStability, tipiExtraverted, tipiOpenness))

  ## Remove personality values from t 2 & 3:
  tlcPersonality$tipiAgreeableness[tlc$time == 2] <- NA
  tlcPersonality$tipiAgreeableness[tlc$time == 3] <- NA
  tlcPersonality$tipiConscientiousness[tlc$time == 2] <- NA
  tlcPersonality$tipiConscientiousness[tlc$time == 3] <- NA
  tlcPersonality$tipiEmotionalStability[tlc$time == 2] <- NA
  tlcPersonality$tipiEmotionalStability[tlc$time == 3] <- NA
  tlcPersonality$tipiExtraverted[tlc$time == 2] <- NA
  tlcPersonality$tipiExtraverted[tlc$time == 3] <- NA
  tlcPersonality$tipiOpenness[tlc$time == 2] <- NA
  tlcPersonality$tipiOpenness[tlc$time == 3] <- NA


  tlcPersonality$sex <- ifelse(!is.na(tlcPersonality$sex) &
                                  tlcPersonality$sex == 0, "male",
                                  ifelse(!is.na(tlcPersonality$sex) & tlcPersonality$sex == 1, "female", NA))

  tlcPersonality$time <- ifelse(!is.na(tlcPersonality$time) &
                                    tlcPersonality$time == 3, "Post",
                                  ifelse(!is.na(tlcPersonality$time) & tlcPersonality$time == 2, "Pre",
                                  ifelse(!is.na(tlcPersonality$time) & tlcPersonality$time == 1, "Baseline", NA)))
  tlcPersonality$time <- factor(tlcPersonality$time, levels = c("Baseline", "Pre",
                                    "Post"), ordered = is.ordered(tlcPersonality$time))

  ##rename columns for tables:

  #library(dplyr)
  tlcPersonality <- dplyr::rename(tlcPersonality, Name = englishName, Sex = sex, Team = team,
                                  Condition = condition, Time = time,
                                   Agreeableness = tipiAgreeableness, Conscientiousness =  tipiConscientiousness,
                                  EmotionalStability = tipiEmotionalStability, Extraverted = tipiExtraverted,
                                  Openness = tipiOpenness)



  ## create a variable list which we want in table one
  listVars <- c("Agreeableness", "Conscientiousness",
                  "EmotionalStability", "Extraverted", "Openness")

  ## define categorical variables
  catVars <- c("Sex", "Condition", "Time")

  ## create table one (high difficulty condition)
  tableTlcPersonality <- CreateTableOne(vars = listVars,
                           strata = "Condition",
                           data = tlcPersonality,
                           factorVars = catVars,
                           test = F
                           )

  ## create table which is printable
  tableTlcPersonality.condition <- print(tableTlcPersonality,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(tableTlcPersonality.condition,
               type="latex",
               caption = "Athlete personality type by condition"),
               file="personalityTraining.tex")
@









\subsection{Data Reduction}
Exploratory factor analysis was used to reduce multicolinearity between variables while retaining as much variance as possible in the observed data \citep{Yong2013}.
%(EFA, appendix ~\ref{appendix:EFA})
Data reduction was performed on the survey items related to the main outcome variables of interest, namely team click and social bonding directed at the training group. The procedure for data reduction followed the method outlined in the previous empirical chapter (Chapter 8).  Moderator variables---technical competence (objective and subjective), components of individual and training group performance, arousal, exertion, and athlete perception of team discipline---were also reduced to factors (see APPENDIX \ref{} HYPERLINK for full description of method).  In addition, items relating to team click and social bonding directed at the provincial team as a whole (and not just the specific training group) were reduced to factors, in order to assess pre- to post-experiment variation in generalised bonding to the team.

\subsubsection{Group Performance relative to prior expectations}
The main predictor variable of interest, perceptions of training group performance relative to prior expectations, was a single item measure, and did not require data reduction.  Considering that the outcome variables of interest (factors) were transformed to standardized z-scores (mean = 0, SD = 1),perceptions of team performance relative to prior expectation was also standardised (mean = 0, SD = 1) for the purposes of equivalence of predictor and outcome variables in subsequent linear mixed effects modelling.

\subsubsection{Feelings of team click within the training group}
<<dataReductionGroupClick, echo=F,eval=T>>=
  #GroupClickVariablesSubset: exclude effectivenessInContact (not relvant)
  ## PROBLEM: groupReliabilityOfOthers, are only measured at t3, and so restrict the creation of a factor across two time points. need to remove for groupClickFactorgroupReliabilityForOthers
  tlcGroupClick <- subset(tlc, select = c(groupAbilitiesExtended, groupClickPictorial,
                                          groupUnspokenUnderstanding, groupGeneralAtmosphere))
  tlcGroupClick.pca <- princomp(na.omit(tlcGroupClick))
  summary(tlcGroupClick.pca)
  plot(tlcGroupClick.pca)

  tlcGroupClick.fa <- factanal(~ groupAbilitiesExtended + groupClickPictorial +
                                        groupUnspokenUnderstanding + groupGeneralAtmosphere, 1,
                                        data = tlc,
                                        rotation = "promax",
                                        na.action = na.exclude,
                                        scores = "regression")  #<- this formula format allows preserving of NAs for later rebind to df
#tlc$groupAbilitiesExtended

  #-----------------------------SS Loadings----------------------#
  SSLoadings.groupClickFA <- round(sum(tlcGroupClick.fa$loadings[,1]^2))
  #------------------Proportion of Variance----------------------#
  prVar.groupClickFA <-  round((colSums(tlcGroupClick.fa$loadings*tlcGroupClick.fa$loadings)/dim(tlcGroupClick.fa$loadings)[1]*100),
                                digits = 1)

  head(tlcGroupClick.fa$scores)
  tlcGroupClick.fa$scores <- unclass(tlcGroupClick.fa$scores)

  tlc <- cbind(tlc, tlcGroupClick.fa$scores)
  colnames(tlc)[which(names(tlc) == "Factor1")] <- "groupClickFactor1"
  tlc$groupClickFactor1 <- unlist(tlc$groupClickFactor1)
  tlc$groupClickFactor1 <- as.vector(tlc$groupClickFactor1)
  #colnames(tlc)[which(names(tlc) == "groupClickFactor1")] <- "groupClickFactor"
  #tlc$groupClickFactor
  #names(tlc)[names(tlc) == "Factor1"] <- "groupClickFactor"

  groupClickMatrix <- cor(tlcGroupClick, use = "complete")

  #---------suitability measures (KMO & Bartlett)----------------#
  KMOgroupClickMatrix <- psych::KMO(groupClickMatrix)
  # KMOGroupClickMatrix$MSA is the colum in which the overal KMO is stored
  bartlettGroupClick <- psych::cortest.bartlett(groupClickMatrix, n = 116) # what is the sample size here?
  # ls(BartlettGroupClick)
  # BartlettGroupClick$chisq, BartlettGroupClick$df, BartlettGroupClick$p.value
  # sample size? length(unique(tlc$englishName)*2)
  groupClickSampleSize <- length(unique(tlc$englishName))*2 # values for each participant measured attwo time points

  #----------reliability measures--------------------------------#
  # Cronbach's Alpha and Guttman's Lambda using psych::alpha()
  #Cronbach's Alpha is located reliabilityObject$total[,2]
  #Guttman's Lambda is located reliabilityObject$total[,3]
  reliabilityGroupClick <- psych::alpha(groupClickMatrix)
  cronAlphaGroupClick <- reliabilityGroupClick$total[,2]
  guttLambdaGroupClick <- reliabilityGroupClick$total[,3]
@
%%Group click post has two extra variables that can be added (Reliability)
<<dataReductionGroupClickPost, echo=F,eval=T>>=
  #GroupClickVariablesSubset: exclude effectivenessInContact (not relvant)
  ## PROBLEM: groupReliabilityOfOthers, are only measured at t3, and so restrict the creation of a factor across two time points. need to remove for groupClickFactorgroupReliabilityForOthers
  tlcGroupClickPost <- subset(tlc, select = c(groupReliabilityOfOthers,
                                            groupReliabilityForOthers, groupAbilitiesExtended,
                                            groupClickPictorial, groupUnspokenUnderstanding, groupGeneralAtmosphere))
  tlcGroupClickPost.pca <- princomp(na.omit(tlcGroupClickPost))
  summary(tlcGroupClickPost.pca)
  plot(tlcGroupClickPost.pca)

  tlcGroupClickPost.fa <- factanal(~ groupReliabilityForOthers + groupReliabilityOfOthers +
                                            groupAbilitiesExtended + groupClickPictorial + groupUnspokenUnderstanding + groupGeneralAtmosphere, 1,
                                            data = tlc,
                                            rotation = "promax",
                                            na.action = na.exclude,
                                            scores = "regression")  #<- this formula format allows preserving of NAs for later rebind to df

  #-----------------------------SS Loadings----------------------#
  SSLoadings.groupClickPostFA <- round(sum(tlcGroupClickPost.fa$loadings[,1]^2), digits = 2)
  #------------------Proportion of Variance----------------------#
  prVar.groupClickPostFA <-  round((colSums(tlcGroupClickPost.fa$loadings*tlcGroupClickPost.fa$loadings)/dim(tlcGroupClickPost.fa$loadings)[1]*100), digits = 1)


  head(tlcGroupClickPost.fa$scores)
  tlc <- cbind(tlc, tlcGroupClickPost.fa$scores)
  names(tlc)[names(tlc) == "Factor1"] <- "groupClickPostFactor"
  groupClickPostMatrix <- cor(tlcGroupClickPost, use = "complete")

  #---------suitability measures (KMO & Bartlett)----------------#
  KMOgroupClickPostMatrix <- psych::KMO(groupClickPostMatrix)
  # KMOGroupClickMatrix$MSA is the colum in which the overal KMO is stored
  bartlettGroupClickPost <- psych::cortest.bartlett(groupClickPostMatrix, n = 116) # what is the sample size here?
  # ls(BartlettGroupClick)
  # BartlettGroupClick$chisq, BartlettGroupClick$df, BartlettGroupClick$p.value
  # sample size? length(unique(tlc$englishName)*2)
  groupClickPostSampleSize <- length(unique(tlc$englishName))*2 # values for each participant measured attwo time points

  #----------reliability measures--------------------------------#
  # Cronbach's Alpha and Guttman's Lambda using psych::alpha()
  #Cronbach's Alpha is located reliabilityObject$total[,2]
  #Guttman's Lambda is located reliabilityObject$total[,3]
  reliabilityGroupClickPost <- psych::alpha(groupClickPostMatrix)
  cronAlphaGroupClickPost <- reliabilityGroupClickPost$total[,2]
  guttLambdaGroupClickPost <- reliabilityGroupClickPost$total[,3]
@
<<groupClickCorr, echo=F,eval=T>>=
  # be sure to import the variable subset data frame, not the correlation matrix
  corstarsl(tlcGroupClick)
  print(xtable(corstarsl(tlcGroupClick), type= "latex",
                      caption = "Correlations between variables of group click",
                      label = "tab:groupClickCorrTable"),
                      file = "groupClickCorrTable.tex")
  # label = tab:groupClickCorrTable
@

Items relating to training group team click (unspoken understanding, general atmosphere, click pictorial, and ability extended by the group) were subjected to EFA.   Correlations between the remaining were very high (all r's > \Sexpr{min(groupClickMatrix)}), which suggested that one factor was appropriate (see Table ee Table ~\ref{tab:groupClickCorrTable}). The KMO index and Bartlett's test both suggested high sampling adequacy, (KMO =  \Sexpr{KMOgroupClickMatrix$MSA}, \chi^2(\Sexpr{bartlettGroupClick$df}, N = \Sexpr{groupClickSampleSize}) = \Sexpr{bartlettGroupClick$chisq}, p = \Sexpr{bartlettGroupClick$p.value}).
One factor, labelled ``Team Click'' was imposed on the data, which explained \Sexpr{prVar.groupClickFA}\% of the overall variance (SS Loading = \Sexpr{SSLoadings.groupClickFA}). Guttmans \lambda = \Sexpr{reliabilityGroupClick$total[,3]} and Cronbachs \alpha = \Sexpr{reliabilityGroupClick$total[,2]} indicated that the data reduction was appropriate and reliable.

In addition to the four variables common to both pre- and post-experiment surveys, athletes were also asked in the post-experiment survey about their own reliability and the reliability of other athletes to perform their role on the field specifically. These two variables, ``Reliability For Others'' and ``Reliability Of Others'' were included in an EFA involving only the post-experiment measures.  The variable ``reliability for others'' was removed from the matrix because it did not significantly correlate with other variables (all r's <= .16).

\subsubsection{Feelings of Social Bonding to the training group}
<<dataReductionGroupBonding, echo=F,eval=T>>=
  #GroupBondingVariablesSubset: exclude effectivenessInContact (not relvant)
  tlcGroupBonding <- subset(tlc, select = c(groupEmotionalSupport, groupSharedGoal,
                                                  groupFusionPictorial))
  tlcGroupBonding.pca <- princomp(na.omit(tlcGroupBonding))
  summary(tlcGroupBonding.pca)
  plot(tlcGroupBonding.pca)

  tlcGroupBonding.fa <- factanal(~ groupEmotionalSupport + groupSharedGoal +
                                        groupFusionPictorial, 1,
                                        data = tlc,
                                        rotation = "promax",
                                        na.action = na.exclude,
                                        scores = "regression")  #<- this formula format allows preserving of NAs for later rebind to df

  #-----------------------------SS Loadings----------------------#
  SSLoadings.groupBondingFA <- round(sum(tlcGroupBonding.fa$loadings[,1]^2), digits = 2)
  #------------------Proportion of Variance----------------------#
  prVar.groupBondingFA <-  round((colSums(tlcGroupBonding.fa$loadings*tlcGroupBonding.fa$loadings)/dim(tlcGroupBonding.fa$loadings)[1]*100),
                                  digits = 1)

  head(tlcGroupBonding.fa$scores)
  tlc <- cbind(tlc, tlcGroupBonding.fa$scores)
  names(tlc)[names(tlc) == "Factor1"] <- "groupBondingFactor"
  groupBondingMatrix <- cor(tlcGroupBonding, use = "complete")

  #---------suitability measures (KMO & Bartlett)----------------#
  KMOgroupBondingMatrix <- psych::KMO(groupBondingMatrix)
  # KMOGroupBondingMatrix$MSA is the colum in which the overal KMO is stored
  bartlettGroupBonding <- psych::cortest.bartlett(groupBondingMatrix, n = 116) # what is the sample size here?
  # ls(BartlettGroupBonding)
  # BartlettGroupBonding$chisq, BartlettGroupBonding$df, BartlettGroupBonding$p.value
  # sample size? length(unique(tlc$englishName)*2)
  groupBondingSampleSize <- length(unique(tlc$englishName))*2 # values for each participant measured attwo time points

  #----------reliability measures--------------------------------#
  # Cronbach's Alpha and Guttman's Lambda using psych::alpha()
  #Cronbach's Alpha is located reliabilityObject$total[,2]
  #Guttman's Lambda is located reliabilityObject$total[,3]
  reliabilityGroupBonding <- psych::alpha(groupBondingMatrix)
  cronAlphaGroupBonding <- reliabilityGroupBonding$total[,2]
  guttLambdaGroupBonding <- reliabilityGroupBonding$total[,3]
@
<<groupBondingCor, echo=F,eval=T>>=
  # be sure to import the variable subset data frame, not the correlation matrix
  corstarsl(tlcGroupBonding)
  print(xtable(corstarsl(tlcGroupBonding), type="latex",
                      caption = "Correlations between group bonding variables",
                      label = "tab:groupBondingCorrTable"),
                      file = "groupBondingCorrTable.tex")
  # label = tab:groupBondingCorrTable
@
Items concerning bonding to the training group (emotional support, shared goal, fusion pictorial) were subjected to EFA.  Correlations between items were high (all r's > \Sexpr{min(groupBondingMatrix)}), which suggested that one factor would be appropriate (see Table ee Table ~\ref{tab:groupBondingCorrTable}). The KMO index and Bartlett's test both suggested high sampling adequacy, (KMO =  \Sexpr{KMOgroupBondingMatrix$MSA}, \chi^2(\Sexpr{bartlettGroupBonding$df}, N = \Sexpr{groupBondingSampleSize}) = \Sexpr{bartlettGroupBonding$chisq}, p = \Sexpr{bartlettGroupBonding$p.value}).
One factor, labelled ``Group Social Bonding'' was imposed on the data, which explained \Sexpr{prVar.groupBondingFA}\% of the overall variance (SS Loading = \Sexpr{SSLoadings.groupBondingFA}). Guttmans \lambda = \Sexpr{reliabilityGroupBonding$total[,3]} and Cronbachs \alpha = \Sexpr{reliabilityGroupBonding$total[,2]} indicated that the data reduction was appropriate and reliable.

\subsubsection{Additional data reduction}
In addition to athlete expectation violations concerning group and individual performance (predictor variable), group click (moderator and outcome variable), and group bonding (outcome variable), measures relating to athlete perceptions of components of group and individual performance, social bonding to the team as a whole, athlete arousal, technical competence (subjective and objective measures), and athlete perceptions of team discipline were subjected to data reduction (see Appendix Section ~\ref{} for full details).

XXXX
<<dataReductionGroupPerformance, echo=F,eval=T>>=
    #groupPerformanceVariablesSubset:
    tlcGroupPerformance <- subset(tlc, select = c(groupDefensiveLine, groupAttackingLine,
                                                      groupSupportPlay, groupOnfieldCommunication))
    tlcGroupPerformance.pca <- princomp(na.omit(tlcGroupPerformance))
    summary(tlcGroupPerformance.pca)
    plot(tlcGroupPerformance.pca)

    tlcGroupPerformance.fa <- factanal(~ groupDefensiveLine + groupAttackingLine +
                                                groupSupportPlay + groupOnfieldCommunication, 1,
                                                 data = tlc,
                                                 rotation = "promax",
                                                 na.action = na.exclude,
                                                 scores = "regression")  #<- this formula format allows preserving of NAs for later rebind to df

    #-----------------------------SS Loadings----------------------#
    SSLoadings.groupPerformanceFA <- round(sum(tlcGroupPerformance.fa$loadings[,1]^2), digits = 2)
    #------------------Proportion of Variance----------------------#
    prVar.GroupPerformanceFA <-  round((colSums(tlcGroupPerformance.fa$loadings*tlcGroupPerformance.fa$loadings)/dim(tlcGroupPerformance.fa$loadings)[1]*100),
                                       digits = 1)


    head(tlcGroupPerformance.fa$scores)
    tlc <- cbind(tlc, tlcGroupPerformance.fa$scores)
    names(tlc)[names(tlc) == "Factor1"] <- "jointActionSuccess"
    groupPerformanceMatrix <- cor(tlcGroupPerformance, use = "complete")

    #---------suitability measures (KMO & Bartlett)----------------#
    KMOgroupPerformanceMatrix <- psych::KMO(groupPerformanceMatrix)
    # KMOGroupPerformanceMatrix$MSA is the colum in which the overal KMO is stored
    bartlettGroupPerformance <- psych::cortest.bartlett(groupPerformanceMatrix, n = 116) # what is the sample size here?
    # ls(BartlettGroupPerformance)
    # BartlettGroupPerformance$chisq, BartlettGroupPerformance$df, BartlettGroupPerformance$p.value
    # sample size? length(unique(tlc$englishName)*2)
    groupPerformanceSampleSize <- length(unique(tlc$englishName))*2 # values for each participant measured attwo time points

    #----------reliability measures--------------------------------#
    # Cronbach's Alpha and Guttman's Lambda using psych::alpha()
    #Cronbach's Alpha is located reliabilityObject$total[,2]
    #Guttman's Lambda is located reliabilityObject$total[,3]
    reliabilityGroupPerformance <- psych::alpha(groupPerformanceMatrix)
    cronAlphaGroupPerformance <- reliabilityGroupPerformance$total[,2]
    guttLambdaGroupPerformance <- reliabilityGroupPerformance$total[,3]


@
<<groupPerformanceCor, echo=F,eval=T>>=
  # be sure to import the variable subset data frame, not the correlation matrix
  corstarsl(tlcGroupPerformance)
  print(xtable(corstarsl(tlcGroupPerformance), type="latex",
                      caption = "Correlations between components of group performance",
                      label = "tab:jointActionSuccessCorrTable"),
                      file = "jointActionSuccessCorrTable.tex")
@
<<dataReductionIndPerformance, echo=F,eval=T>>=
    #indPerformanceVariablesSubset: exclude effectivenessInContact (not relevant)
    tlcIndPerformance <- subset(tlc, select = c(indDefense, passingTechnique, supportPlay,
                                                      decisionMaking))
    tlcIndPerformance.pca <- princomp(na.omit(tlcIndPerformance))
    summary(tlcIndPerformance.pca)
    plot(tlcIndPerformance.pca)

    tlcIndPerformance.fa <- factanal(~ indDefense + passingTechnique + supportPlay +
                                            decisionMaking, 1, data = tlc, rotation = "promax",
                                            na.action = na.exclude, scores = "regression")
    #<- this formula format allows preserving of NAs for later rebind to df

    #-----------------------------SS Loadings----------------------#
    SSLoadings.indPerformanceFA <- round(sum(tlcIndPerformance.fa$loadings[,1]^2), digits = 2)
    #------------------Proportion of Variance----------------------#
    prVar.indPerformanceFA <-  round((colSums(tlcIndPerformance.fa$loadings*tlcIndPerformance.fa$loadings)/dim(tlcIndPerformance.fa$loadings)[1]*100),
                                     digits = 1)


    head(tlcIndPerformance.fa$scores)
    tlc <- cbind(tlc, tlcIndPerformance.fa$scores)
    names(tlc)[names(tlc) == "Factor1"] <- "indComponentsPerformance"
    indPerformanceMatrix <- cor(tlcIndPerformance, use = "complete")

    #---------suitability measures (KMO & Bartlett)----------------#
    KMOindPerformanceMatrix <- psych::KMO(indPerformanceMatrix)
    # KMOIndPerformanceMatrix$MSA is the colum in which the overal KMO is stored
    bartlettIndPerformance <- psych::cortest.bartlett(indPerformanceMatrix, n = 116) # what is the sample size here?
    # ls(BartlettIndPerformance)
    # BartlettIndPerformance$chisq, BartlettIndPerformance$df, BartlettIndPerformance$p.value
    # sample size? length(unique(tlc$englishName)*2)
    indPerformanceSampleSize <- length(unique(tlc$englishName))*2 # values for each participant measured attwo time points

    #----------reliability measures--------------------------------#
    # Cronbach's Alpha and Guttman's Lambda using psych::alpha()
    #Cronbach's Alpha is located reliabilityObject$total[,2]
    #Guttman's Lambda is located reliabilityObject$total[,3]
    reliabilityIndPerformance <- psych::alpha(indPerformanceMatrix)
    cronAlphaIndPerformance <- reliabilityIndPerformance$total[,2]
    guttLambdaIndPerformance <- reliabilityIndPerformance$total[,3]
@
<<indComponentsPerformanceCor, echo=F,eval=T>>=
  # be sure to import the variable subset data frame, not the correlation matrix
  corstarsl(tlcIndPerformance)
  print(xtable(corstarsl(tlcIndPerformance), type="latex",
                      caption = "Correlations between components of individual performance",
                      label = "tab:indComponentPerfCorrTable"),
                      file = "indComponengtPerfCorrTable.tex")
  # label = tab:indComponentPerformanceCorrTable
@
<<dataReductionTeamBonding, eval=TRUE, echo=FALSE>>=
  #TeamBondingVariablesSubset: exclude effectivenessInContact (not relvant)
  tlcTeamBonding <- subset(tlc, select = c(emotionalSupport, sharedGoal,
                                                fusionPictorialTeam, fusionVerbal, groupId))
  tlcTeamBonding.pca <- princomp(na.omit(tlcTeamBonding))
  summary(tlcTeamBonding.pca)
  #plot(tlcTeamBonding.pca)

  tlcTeamBonding.fa <- factanal(~ emotionalSupport + sharedGoal +
                                        fusionPictorialTeam + fusionVerbal + groupId, 1,
                                        data = tlc,
                                        rotation = "promax",
                                        na.action = na.exclude,
                                        scores = "regression")  #<- this formula format allows preserving of NAs for later rebind to df

  #-----------------------------SS Loadings----------------------#
  SSLoadings.teamBondingFA <- round(sum(tlcTeamBonding.fa$loadings[,1]^2), digits = 2)
  #------------------Proportion of Variance----------------------#
  prVar.teamBondingFA <-  round((colSums(tlcTeamBonding.fa$loadings*tlcTeamBonding.fa$loadings)/dim(tlcTeamBonding.fa$loadings)[1]*100),
                                digits = 1)

  head(tlcTeamBonding.fa$scores)
  tlc <- cbind(tlc, tlcTeamBonding.fa$scores)
  names(tlc)[names(tlc) == "Factor1"] <- "teamBondingFactor"
  teamBondingMatrix <- cor(tlcTeamBonding, use = "complete")

  #---------suitability measures (KMO & Bartlett)----------------#
  KMOteamBondingMatrix <- psych::KMO(teamBondingMatrix)
  # KMOTeamBondingMatrix$MSA is the colum in which the overal KMO is stored
  bartlettTeamBonding <- psych::cortest.bartlett(teamBondingMatrix, n = 116) # what is the sample size here?
  # ls(BartlettTeamBonding)
  # BartlettTeamBonding$chisq, BartlettTeamBonding$df, BartlettTeamBonding$p.value
  # sample size? length(unique(tlc$englishName)*2)
  teamBondingSampleSize <- length(unique(tlc$englishName))*2 # values for each participant measured attwo time points

  #----------reliability measures--------------------------------#
  # Cronbach's Alpha and Guttman's Lambda using psych::alpha()
  #Cronbach's Alpha is located reliabilityObject$total[,2]
  #Guttman's Lambda is located reliabilityObject$total[,3]
  reliabilityTeamBonding <- psych::alpha(teamBondingMatrix)
  cronAlphaTeamBonding <- reliabilityTeamBonding$total[,2]
  guttLambdaTeamBonding <- reliabilityTeamBonding$total[,3]
@
<<teamBondingCor, echo=F,eval=T>>=
  # be sure to import the variable subset data frame, not the correlation matrix
  corstarsl(tlcTeamBonding)
  print(xtable(corstarsl(tlcTeamBonding), type="latex",
                      caption = "Correlations between team bonding variables",
                      label = "tab:teamBondingCorrTable"),
                      file = "teamBondingCorrTable.tex")
  # label = tab:teamBondingCorrTable
@

<<dataReductionArousal, echo=F,eval=T>>=
  #ArousalVariablesSubset: exclude effectivenessInContact (not relvant)
  tlcArousal <- subset(tlc, select = c(aroused, relaxed, excited))
  tlcArousal.pca <- princomp(na.omit(tlcArousal))
  summary(tlcArousal.pca)
  #plot(tlcArousal.pca)

  tlcArousal.fa <- factanal(~ aroused + relaxed + excited, 1,
                            data = tlc,
                            rotation = "promax",
                            na.action = na.exclude,
                            scores = "regression")  #<- this formula format allows preserving of NAs for later rebind to df

  #-----------------------------SS Loadings----------------------#
  SSLoadings.ArousalFA <- round(sum(tlcArousal.fa$loadings[,1]^2), digits = 2)
  #------------------Proportion of Variance----------------------#
  prVar.ArousalFA <-  round((colSums(tlcArousal.fa$loadings*tlcArousal.fa$loadings)/dim(tlcArousal.fa$loadings)[1]*100),
                            digits = 1)

  head(tlcArousal.fa$scores)
  tlc <- cbind(tlc, tlcArousal.fa$scores)
  names(tlc)[names(tlc) == "Factor1"] <- "arousalFactor"
  arousalMatrix <- cor(tlcArousal, use = "complete")

  #---------suitability measures (KMO & Bartlett)----------------#
  KMOarousalMatrix <- psych::KMO(arousalMatrix)
  # KMOarousalMatrix$MSA is the colum in which the overal KMO is stored
  bartlettArousal <- psych::cortest.bartlett(arousalMatrix, n = 116) # what is the sample size here?
  # ls(BartlettArousal)
  # BartlettArousal$chisq, BartlettArousal$df, BartlettArousal$p.value
  # sample size? length(unique(tlc$englishName)*2)
  arousalSampleSize <- length(unique(tlc$englishName))*2 # values for each participant measured attwo time points

  #----------reliability measures--------------------------------#
  # Cronbach's Alpha and Guttman's Lambda using psych::alpha()
  #Cronbach's Alpha is located reliabilityObject$total[,2]
  #Guttman's Lambda is located reliabilityObject$total[,3]
  reliabilityArousal <- psych::alpha(arousalMatrix)
  cronAlphaArousal <- reliabilityArousal$total[,2]
  guttLambdaArousal <- reliabilityArousal$total[,3]
@


<<arousalCor, echo=F,eval=T>>=
  # be sure to import the variable subset data frame, not the correlation matrix
  corstarsl(tlcArousal)
  print(xtable(corstarsl(tlcArousal), type="latex",
                      caption = "Correlations between variables measuring arousal",
                      label = "tab:arousalCorrTable"),
                      file = "arousalCorrTable.tex")
  # label = tab:arousalCorrTable
@

<<dataReductionTeamDiscipline, eval=T, echo=F>>=
  #TeamDisciplineVariablesSubset: exclude effectivenessInContact (not relvant)
  tlcTeamDiscipline <- subset(tlc, select = c(teamAttendanceMeals, teamCurfew, teamGeneralConduct, teamPunctuality))
  tlcTeamDiscipline.pca <- princomp(na.omit(tlcTeamDiscipline))
  summary(tlcTeamDiscipline.pca)
  #plot(tlcTeamDiscipline.pca)

  tlcTeamDiscipline.fa <- factanal(~ teamAttendanceMeals + teamCurfew + teamGeneralConduct +
                                        teamPunctuality, 1,
                                   data = tlc,
                                   rotation = "promax",
                                   na.action = na.exclude,
                                   scores = "regression")  #<- this formula format allows preserving of NAs for later rebind to df

  #-----------------------------SS Loadings----------------------#
  SSLoadings.teamDisciplineFA <- round(sum(tlcTeamDiscipline.fa$loadings[,1]^2), digits = 2)
  #------------------Proportion of Variance----------------------#
  prVar.teamDisciplineFA <-  round((colSums(tlcTeamDiscipline.fa$loadings*tlcTeamDiscipline.fa$loadings)/dim(tlcTeamDiscipline.fa$loadings)[1]*100), digits = 1)

  head(tlcTeamDiscipline.fa$scores)
  tlc <- cbind(tlc, tlcTeamDiscipline.fa$scores)
  names(tlc)[names(tlc) == "Factor1"] <- "teamDisciplineFactor"
  teamDisciplineMatrix <- cor(tlcTeamDiscipline, use = "complete")

  #---------suitability measures (KMO & Bartlett)----------------#
  KMOteamDisciplineMatrix <- psych::KMO(teamDisciplineMatrix)
  # KMOTeamDisciplineMatrix$MSA is the colum in which the overal KMO is stored
  bartlettTeamDiscipline <- psych::cortest.bartlett(teamDisciplineMatrix, n = 116) # what is the sample size here?
  # ls(BartlettTeamDiscipline)
  # BartlettTeamDiscipline$chisq, BartlettTeamDiscipline$df, BartlettTeamDiscipline$p.value
  # sample size? length(unique(tlc$englishName)*2)
  teamDisciplineSampleSize <- length(unique(tlc$englishName))*2 # values for each participant measured attwo time points

  #----------reliability measures--------------------------------#
  # Cronbach's Alpha and Guttman's Lambda using psych::alpha()
  #Cronbach's Alpha is located reliabilityObject$total[,2]
  #Guttman's Lambda is located reliabilityObject$total[,3]
  reliabilityTeamDiscipline <- psych::alpha(teamDisciplineMatrix)
  cronAlphaTeamDiscipline <- reliabilityTeamDiscipline$total[,2]
  guttLambdaTeamDiscipline <- reliabilityTeamDiscipline$total[,3]
@


<<teamDisciplineCor, echo=F,eval=T>>=
  # be sure to import the variable subset data frame, not the correlation matrix
  corstarsl(tlcTeamDiscipline)
  print(xtable(corstarsl(tlcTeamDiscipline), type="latex",
                      caption = "Correlations between variables measuring team discipline",
                      label = "tab:teamDisciplineCorrTable"),
                      file = "teamDisciplineCorrTable.tex")
  # label = tab:teamDisciplineCorrTable
@





<<dataReductionTechnicalCompetence, eval=TRUE, echo=FALSE>>=
  #TechnicalCompetenceVariablesSubset:
  tlcTechnicalCompetence <- subset(tlc, select = c(yearsTeam, trainingAge, teamStatus,
                                            athleteStatus, indAbilityTeammates_1, indAbilityChina_1,
                                            indAbilityInternational_1, teamAbilityChina_1))
  tlcTechnicalCompetence.pca <- princomp(na.omit(tlcTechnicalCompetence))
  summary(tlcTechnicalCompetence.pca)
  #plot(tlcTechnicalCompetence.pca)

  tlcTechnicalCompetence.fa <- factanal(~ yearsTeam + trainingAge  + teamStatus +
                                            athleteStatus + indAbilityTeammates_1 + indAbilityChina_1 + indAbilityInternational_1, 2,
                                            data = tlc,
                                        rotation = "promax",
                                        na.action = na.exclude,
                                        scores = "regression")  #<- this formula format allows preserving of NAs for later rebind to df

  #-----------------------------SS Loadings----------------------#
  SSLoadings.objectiveCompetenceFA <- round(sum(tlcTechnicalCompetence.fa$loadings[,1]^2),
                                                digits = 2)

  SSLoadings.subjectiveCompetenceFA <- round(sum(tlcTechnicalCompetence.fa$loadings[,2]^2),
                                                digits = 2)
  #------------------Proportion of Variance----------------------#
  prVar.technicalCompetenceFA <-  round((colSums(tlcTechnicalCompetence.fa$loadings*tlcTechnicalCompetence.fa$loadings)/dim(tlcTechnicalCompetence.fa$loadings)[1]*100),
                                        digits = 1)

  unclass(prVar.technicalCompetenceFA)
  prVar.technicalCompetenceFA <- data.frame(prVar.technicalCompetenceFA)
  prVar.objectiveCompetenceFA <- prVar.technicalCompetenceFA[1,1]
  prVar.subjectiveCompetenceFA <- prVar.technicalCompetenceFA[2,1]


  head(tlcTechnicalCompetence.fa$scores)
  tlc <- cbind(tlc, tlcTechnicalCompetence.fa$scores)
  names(tlc)[names(tlc) == "Factor1"] <- "objectiveCompetenceFactor"
  names(tlc)[names(tlc) == "Factor2"] <- "subjectiveCompetenceFactor"
  technicalCompetenceMatrix <- cor(tlcTechnicalCompetence
                                          , use = "complete")
  objectiveCompetenceMatrix <- cor(subset(tlcTechnicalCompetence
                                          , select = c(yearsTeam, trainingAge, teamStatus, athleteStatus)
                                        )
                                          , use = "complete"
                                        )
          min(objectiveCompetenceMatrix)
  subjectiveCompetenceMatrix <- cor(subset(tlcTechnicalCompetence
                                          , select = c(indAbilityTeammates_1, indAbilityChina_1, indAbilityInternational_1)
                                        )
                                          , use = "complete"
                                      )
            min(subjectiveCompetenceMatrix)

  #---------suitability measures (KMO & Bartlett)----------------#
  library(psych)
  KMOtechnicalCompetenceMatrix <- psych::KMO(technicalCompetenceMatrix)
  # KMOTechnicalCompetenceMatrix$MSA is the colum in which the overal KMO is stored
  bartlettTechnicalCompetence <- psych::cortest.bartlett(technicalCompetenceMatrix, n = 116) # what is the sample size here?
  # ls(BartlettTechnicalCompetence)
  # BartlettTechnicalCompetence$chisq, BartlettTechnicalCompetence$df, BartlettTechnicalCompetence$p.value
  # sample size? length(unique(tlc$englishName)*2)
  technicalCompetenceSampleSize <- length(unique(tlc$englishName)) # values for each participant measured at one time points

  #----------reliability measures--------------------------------#
  # Cronbach's Alpha and Guttman's Lambda using psych::alpha()
  #Cronbach's Alpha is located reliabilityObject$total[,2]
  #Guttman's Lambda is located reliabilityObject$total[,3]
  reliabilityTechnicalCompetence <- psych::alpha(technicalCompetenceMatrix)
  cronAlphaTechnicalCompetence <- reliabilityTechnicalCompetence$total[,2]
  guttLambdaTechnicalCompetence <- reliabilityTechnicalCompetence$total[,3]
@
<<technicalCompetenceCor, echo=F,eval=T>>=
  # be sure to import the variable subset data frame, not the correlation matrix
  corstarsl(tlcTechnicalCompetence)
  print(xtable(corstarsl(tlcTechnicalCompetence), type="latex",
                      caption = "Correlations between measures of technical competence",
                      label = "tab:technicalCompetenceCorrTable"),
                      file = "technicalCompetenceCorrTable.tex")
  # label = tab:technicalCompetenceCorrTable
@

<<factorsAttachWideFormat, echo=F,eval=T>>=
  #attach factors to wide-format variable:
  # jointActionSuccess:
  twc$jointActionSuccessPost <- tlc$jointActionSuccess[tlc$time == 3]
  twc$jointActionSuccessPre <- tlc$jointActionSuccess[tlc$time == 2]
  # indPerformanceComponents:
  twc$indPerformanceComponentsPost <- tlc$indPerformanceComponents[tlc$time == 3]
  twc$indPerformanceComponentsPre <- tlc$indPerformanceComponents[tlc$time == 2]
  # groupClick
  twc$groupClickFactorPost <- tlc$groupClickFactor1[tlc$time == 3]
  twc$groupClickFactorPre <- tlc$groupClickFactor1[tlc$time == 2]
  twc$groupClickPostFactor <- tlc$groupClickPost[tlc$time == 3]
  # groupBonding
  twc$groupBondingFactorPost <- tlc$groupBondingFactor[tlc$time == 3]
  twc$groupBondingFactorPre <- tlc$groupBondingFactor[tlc$time == 2]
  #arousalFactor
  twc$arousalFactorPre <- tlc$arousalFactor[tlc$time == 2]
  twc$arousalFactorPost <- tlc$arousalFactor[tlc$time == 3]
  #objectiveCompetence:
  twc$objectiveCompetenceFactor <- tlc$objectiveCompetenceFactor[tlc$time == 1]
  #subjectiveCompetence:
  twc$subjectiveCompetenceFactor <- tlc$subjectiveCompetenceFactor[tlc$time == 1]
  #teamBondingFactor:
  twc$teamBondingFactorBaseline <- tlc$teamBondingFactor[tlc$time == 1]
  twc$teamBondingFactorPost <- tlc$teamBondingFactor[tlc$time == 3]
  #teamDisciplineFactor:
  twc$teamDisciplineFactor <- tlc$teamDisciplineFactor[tlc$time == 1]
@








\subsection{Manipulation Checks}
The effectiveness of the experimental manipulation was assesed based on a comparison of athletes responses to three survey items immediately following the high or low difficulty prime and immediately before the training drill.
Athletes were asked about their confidence in their individual and training group's ability to handle the technical challenges of the training drill.
Due to the fact that athletes had been primed to expect either a difficult or simple training drill, it was expected that athletes in the high difficulty condition would be less confident about their own and their group's ability to meet the technical challenges of the training session.
In addition to self-reported confidence, it was also predicted that athlete self-reports of arousal, measured measured at the same time as the previous questions regarding confidence, would also vary according to condition.
It was predicted that that athletes in the high difficulty condition would be more aroused than athtletes in the low difficulty condition.  Meaningful variation in these variables could be used to check that the experimental manipulation was successful.

<<manipulationChecksPrep2, echo=F,eval=T>>=
  #condition differences in:
  # 1. groupConfidentTechnicalChallenges,
  # 2. indConfidenceChallenges,
  # 3. arousal
  #subset df according to condition:
  low <- subset(twc, condition == "low")
  high <- subset(twc, condition == "high")
@

<<standardise groupPerformance_3_1, eval=T, echo=F>>=
  #standardise groupPerformance_3:
  #twc$groupPerformance_3Norm <- scale(twc$groupPerformance_3)
  #twc$indPerformance_3Norm <- scale(twc$indPerformance_3)
@


<<manipulationCheckTable, echo=F,eval=T>>=

  ##subset data for table: groupConfidentTechnicalChallenges_2,indConfidenceChallenges_2, arousalFactorPre:
  twcManipulationCheck <- subset(twc, select = c(age, sex, condition, team,
                                      groupConfidentTechnicalChallenges_2, indConfidenceChallenges_2, arousalFactorPre,
                                      groupPerformance_3Norm, indPerformance_3Norm, groupClickPostFactor, groupBondingFactorPost))
  ##rename columns for tables:
  library(dplyr)
  twcManipulationCheck <- dplyr::rename(twcManipulationCheck, Condition = condition,
                                      ConfidenceInGroupAbility = groupConfidentTechnicalChallenges_2,
                                      ConfidenceIndividualAbility = indConfidenceChallenges_2,
                                      Arousal = arousalFactorPre, GroupPerformVsExpected = groupPerformance_3Norm,
                                      IndPerformVsExpected = indPerformance_3Norm, GroupClickPost = groupClickPostFactor,
                                      GroupBondingPost = groupBondingFactorPost)


  ## create a variable list which we want in table one
  listVars <- c("ConfidenceInGroupAbility", "ConfidenceIndividualAbility", "Arousal")

  ## define categorical variables
  catVars <- c("Condition")


  ## Create overall table:
  table1 <- CreateTableOne(vars = listVars,
                           strata = "Condition",
                           data = twcManipulationCheck,
                           factorVars = catVars,
                           test = FALSE
                           )

  ## create table which is printable
  table1_overall <- print(table1,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )


  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(table1_overall, type="latex",
        caption = "Pre-experiment manipulation check variables",
        label = "tab:manipulationCheckTable"),
        file="manipulationCheckTable.tex")
@

<<groupConfChallengesTtest, echo=F,eval=T>>=
  groupConfidenceCondition.ttest <- t.test(high$groupConfidentTechnicalChallenges_2, low$groupConfidentTechnicalChallenges_2)
@

%%% group confidence in technical challenges:
<<groupConfChallengesBoxplot, echo=F,eval=T>>=
  boxplot(groupConfidentTechnicalChallenges_2 ~ condition,
                                        varwidth = TRUE,
                                        width = c(.5,.5),
                                        notch = F,
                                        main = NA,
                                        xlab = "Condition",
                                        ylab = "Confidence",
                                        data = twc)
@
<<histHighGroupConfidence, echo=F,eval=T>>=
  hist(high$groupConfidentTechnicalChallenges_2,
                                          main = NA,
                                          xlab = "Confidence",
                                          xlim = c(0, 100))
@
<<histLowGroupConfidence,echo=F,eval=T>>=
  hist(low$groupConfidentTechnicalChallenges_2,
                                        main = NA,
                                        xlab = "Confidence",
                                        xlim = c(0, 100))
@

<<groupConfidenceVariance, echo=F,eval=T>>=
  library(car)
  groupConfPerfBartlett <- bartlett.test(groupConfidentTechnicalChallenges_2 ~ condition,
                                                          data = twc)
  #library(stats)
  #var.test(high$groupConfidentTechnicalChallenges_2,low$groupConfidentTechnicalChallenges_2)
                                          # variance does not appear to differ significantly
@

<<groupConfidenceConditionLMER, echo=F,eval=T>>=
library(lmerTest)
  # normalise DV:
   twc$groupConfidentTechnicalChallenges_2Norm <- scale(twc$groupConfidentTechnicalChallenges_2)

  #twc$condition <- factor(twc$condition, levels = c("low", "high"), ordered = TRUE)
  # model
  summary(conditionGroupConf.main <- lmer(groupConfidentTechnicalChallenges_2Norm ~ condition
                            + objectiveCompetenceFactor + subjectiveCompetenceFactor
                            + (1 |sessionName)
                            , data = twc
                            , REML = F
                          )
          )
  #CIs
  conditionGroupConf.main.CIs <- confint.merMod(conditionGroupConf.main, method = "Wald", level = 0.95)

@




<<indConfChallengesTtest, echo=F,eval=T>>=
  indConfidenceCondition.ttest <- t.test(high$indConfidenceChallenges_2, low$indConfidenceChallenges_2)
@

<<indConfChallengesBoxplot, echo=F,eval=T>>=
  indConfConditionBoxPlot <- boxplot(indConfidenceChallenges_2 ~ condition,
                                          varwidth = TRUE,
                                          width = c(.5,.5),
                                          notch = F,
                                          main = NA,
                                          xlab = "Condition",
                                          ylab = "Confidence",
                                          data = twc)
@

<<histHighIndConfidence, echo=F,eval=T>>=
  histHighIndConfidence <- hist(high$indConfidenceChallenges_2,
                                          main = NA,
                                          xlab = "Confidence",
                                          xlim = c(0, 100),
                                          ylim = c(0, 20))
@

<<histLowIndConfidence, echo=F,eval=T>>=
  histLowIndConfidence <- hist(low$indConfidenceChallenges_2,
                                        main = NA,
                                        xlab = "Confidence",
                                        xlim = c(0, 100),
                                        ylim = c(0, 20))
  # t.test(high$indConfidenceChallenges_2, low$indConfidenceChallenges_2)
@
<<indConfidenceVariance, echo=F,eval=T>>=
  car::leveneTest(indConfidenceChallenges_2 ~ condition, data = twc)
  fligner.test(indConfidenceChallenges_2 ~ condition, data = twc)
indPerfBartlett <-  bartlett.test(indConfidenceChallenges_2 ~ condition, data = twc)

 # variance appears to differ significantly
  indPerfFTestVariance <- stats::var.test(high$indConfidenceChallenges_2, low$indConfidenceChallenges_2)
  # variance appears to differ significantly
  #cohens_d(indPerfBartlett, format = "latex")
  #apa(indPerfBartlett)
@


<<indConfChallengesLMER, echo=F,eval=T>>=

twc$indConfidenceChallenges_2Norm <- scale(twc$indConfidenceChallenges_2)

summary(indConfChallenges.main <- lmer(indConfidenceChallenges_2Norm ~ condition
                            + objectiveCompetenceFactor + subjectiveCompetenceFactor
                            + (1 |sessionName)
                            , data = twc
                            , REML = F
                          )
          )

#CIs
indConfChallenges.main.CIs <- confint.merMod(indConfChallenges.main, method = "Wald", level = 0.95)



@





%(\Sexpr{t_test(groupConfidenceCondition.ttest)})
 %(\Sexpr{t_test(indConfidenceCondition.ttest)})
Results of manipulation checks indicate that there were no overall condition-wise differences in athlete confidence in group or individual ability to meet the technical challenges of the drill (see Table ~\ref{tab:manipulationCheckTable} and Figures ~\ref{fig:groupConfChallengesBoxplot} and ~\ref{fig:indConfChallengesBoxplot}).
Although the central tendency of these variables was not significantly different, the box plots (Figures ~\ref{fig:groupConfChallengesBoxplot}) and histograms of both group and individual confidence variables by condition show that the variance of responses in the high difficulty condition appears to be larger than the low difficulty condition (see Figures ~\ref{fig:histHighGroupConfidence}\nobreakdash~\ref{fig:histLowIndConfidence}).
A Bartlett's test of homogeneity of variance revealed that there was no meaningful difference in variance of confidence in group ability (\Sexpr{groupConfPerfBartlett}). The same test applied to athlete confidence in individual ability according to condition did, however, reveal a significant difference, \Sexpr{indPerfBartlett}.

<<arousalConditionttest, echo=F,eval=T>>=
  arousalCondition.ttest <- t.test(twc$arousalFactorPre[twc$condition == "high"],
                                   twc$arousalFactorPre[twc$condition == "low"])
@
<<arousalFactorPreBoxPlot, fig.cap=''>>=
  arousalFactorPreBoxPlot <- boxplot(arousalFactorPre ~ condition,
                                        varwidth = TRUE,
                                        width = c(.5,.5),
                                        notch = F,
                                        main = NA,
                                        xlab = "Condition",
                                        ylab = "Arousal",
                                        data = twc)
@

<<histArousalFactorPreHigh, fig.cap=''>>=
  histArousalFactorPreHigh <- hist(high$arousalFactorPre,
                                        main = NA,
                                        xlab = "Arousal",
                                        xlim = c(-3, 2),
                                        ylim = c(0,10))
@

<<histArousalFactorPreLow, fig.cap=''>>=
  hist(low$arousalFactorPre,
                              main = NA,
                              xlab = "Arousal",
                              xlim = c(-3, 2),
                              ylim = c(0,10))
@


<<arousalFactorPreConditionLMER, echo=F,eval=T>>=

  #twc$condition <- factor(twc$condition, levels = c("low", "high"), ordered = TRUE)
summary(arousalFactorPreCondition.main <- lmer(arousalFactorPre ~ condition
                            + objectiveCompetenceFactor + subjectiveCompetenceFactor
                            + (1|sessionName)
                            , data = twc
                            , REML = F
                          )
          )

#CIs
arousalFactorPreCondition.main.CIs <- confint.merMod(arousalFactorPreCondition.main, method = "Wald", level = 0.95)


@





<<arousalVariance, echo=F,eval=T>>=
  ##leveneTest(arousalFactorPre ~ condition, data = twc)
  #fligner.test(arousalFactorPre ~ condition, data = twc)
    arousalFactorPreBartlett <- bartlett.test(arousalFactorPre ~ condition, data = twc) # all n.s.
  #this is only measured at time = 2!
  #standard deviation seems to be bigger in high difficulty condition:
  #groupConfidenceHighSd <- sd(high$groupConfidentTechnicalChallenges_2, na.rm = TRUE)
  #groupConfidenceLowSd <- sd(low$groupConfidentTechnicalChallenges_2, na.rm = TRUE)
  #hist(high$groupConfidentTechnicalChallenges_2)
  #hist(low$groupConfidentTechnicalChallenges_2)

  # individual confidence in technical challenges:
  #boxplot(indConfidenceChallenges_2 ~ condition, data = twc) #this is only measured at time = 2!
  #standard deviation seems to be bigger in high difficulty condition:
  #indConfidenceHighSd <- sd(high$indConfidenceChallenges_2, na.rm = TRUE)
  #indConfidenceLowSd <- sd(low$indConfidenceChallenges_2, na.rm = TRUE)
  #hist(high$indConfidenceChallenges_2)
  #hist(low$indConfidenceChallenges_2)
  #arousal
  #boxplot(arousalFactorPre ~ condition, data = twc)
  # high difficulty condition looks like higher arousal annd higher variance
@

%\Sexpr{t_apa(arousalCondition.ttest)}
An analysis of arousal by condition also failed to reveal meaningful variation by condition, (see Table ~\ref{tab:manipulationCheckTable} and Figure ~\ref{fig:arousalFactorPreBoxPlot}). Judging by the boxplot and histogram of each condition (see Figures ~\ref{fig:histArousalFactorPreHigh} and ~\ref{fig:histArousalFactorPreLow}), the variance of arousal in the high difficulty condition did appear to be higher than the low difficulty condition. A Bartlett's test for homogeneity of variance, however, revealed that the difference was not significant, \Sexpr{arousalFactorPreBartlett}. These results suggested that the experimental prime was explicitly successful in significantly manipulating athlete self-reported confidence in individuala and group ability to meet the technical challenges associated with the training drill.  There was also no evidence that self-reported arousal differed significantly according to condition.
It was still possible, however, that the experimental primes influenced athletes implicitly, in ways that were not measured by surveys, which record explicit self-report.

\subsection{Results by condition}
Predictions of this study were first tested according to condition. It was predicted that the high difficulty prime would generate closer attention to the details of joint action between participants, and more positive violation of expectations around group performance.

<<performanceConditionPostTable, echo=F,eval=T>>=
  ##subset data for renaming
  twcPerformancePost <- subset(twc, select = c(age, sex, condition, team,
                                      jointActionSuccessPost, indPerformancePost, groupPerformance_3Norm, indPerformance_3Norm))

  ##rename columns for tables:
  library(dplyr)
  twcPerformancePost <- dplyr::rename(twcPerformancePost, Team = team, Condition = condition,
                                      Sex = sex, Age = age, JointActionSuccess = jointActionSuccessPost,
                                      IndividualComponentPerformance = indPerformancePost, GroupPerformVsExpected = groupPerformance_3Norm,
                                      IndPerformVsExpected = indPerformance_3Norm)

      twcPerformancePost$GroupPerformVsExpected <- as.numeric(twcPerformancePost$GroupPerformVsExpected)
      twcPerformancePost$IndPerformVsExpected <- as.numeric(twcPerformancePost$IndPerformVsExpected)

  ## create a variable list which we want in table one
  listVars <- c("GroupPerformVsExpected", "IndPerformVsExpected", "JointActionSuccess", "IndividualComponentPerformance")

  ## define categorical variables
  catVars <- c("Condition")


  ## Create overall table:
  table1 <- CreateTableOne(vars = listVars,
                           strata = "Condition",
                           data = twcPerformancePost,
                           factorVars = catVars,
                           test = FALSE
                           )

  ## create table which is printable
  table1_overall <- print(table1,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(table1_overall, type="latex",
                      main = "Athlete perceptions of performance post-experiment",
                      label = "tab:performanceConditionPost"),
                      file="performanceConditionPost.tex")
@

%% jointACtionSuccess & indPerformance:
<<groupJointActionSuccessPostBoxPlot, fig.cap=''>>=
  groupJointActionSuccessBoxPlot <- boxplot(jointActionSuccessPost ~ condition,
                                          varwidth = TRUE,
                                          width = c(.5,.5),
                                          notch = F,
                                          main = NA,
                                          xlab = "Condition",
                                          ylab = "Joint Action Success",
                                          data = twc)
@
<<indComponentPerformancePostBoxPlot, fig.cap=''>>=
  indComponentPerformancePostBoxPlot <- boxplot(indPerformancePost ~ condition,
                                          varwidth = TRUE,
                                          width = c(.5,.5),
                                          notch = F,
                                          main = NA,
                                          xlab = "Condition",
                                          ylab = "Individual Performance",
                                          data = twc)
@
<<groupPerfExpPostBoxPlot, fig.cap=''>>=
  groupPerfExpPostBoxPlot <- boxplot(groupPerformance_3Norm ~ condition,
                                          varwidth = TRUE,
                                          width = c(.5,.5),
                                          notch = F,
                                          xlab = "Condition",
                                          ylab = "Group Performance vs. Expectations",
                                          data = twc)
@
<<indPerfExpPostBoxPlot, fig.cap=''>>=
  indPerfExpPostBoxPlot <- boxplot(indPerformance_3Norm ~ condition,
                                          varwidth = TRUE,
                                          width = c(.5,.5),
                                          notch = F,
                                          main = NA,
                                          xlab = "Condition",
                                          ylab = "Individual Performance vs. Expectations",
                                          data = twc)
# t.test(high$indPerformance_3, low$indPerformance_3)
@

As Table ~\ref{tab:performanceConditionPost} shows, there were no observable significant differences between conditions in athlete perceptions of joint action success, individual component performance, group performance relative to prior expectations, or individual performance relative to prior expectations (see also box plots comparing these factors by condition, Figures ~\ref{fig:groupJointActionSuccessPostBoxPlot}\nobreakdash~\ref{fig:indPerfExpPostBoxPlot}). These results hold when controlling for an athlete's confidence in individual and group performance reported at time 2 prior to the experiment (see APPENDIX for detailed results).

<<postExperimentPerformanceControls, echo=F, eval=T>>=
  summary(lm(twc$jointActionSuccessPost ~ twc$condition + twc$jointActionSuccessPre + twc$groupConfidentTechnicalChallenges_2))

  summary(lm(twc$indPerformancePost ~ twc$condition + twc$indPerformance_2 + twc$indConfidenceChallenges_2))

  summary(lm(twc$groupPerformance_3 ~ twc$condition + twc$groupConfidentTechnicalChallenges_2))

  summary(lm(twc$indPerformance_3 ~ twc$condition + twc$indPerformance_2 + twc$indConfidenceChallenges_2))
@
<<manipulationChecks3, echo=F,eval=T>>=
  #check if there are any meaningful changes in post-Experiment click and bonding
@

<<clickBondConditionPostTable, echo=F,eval=T>>=
  ##subset data for renaming
  twcClickBondPost <- subset(twc, select = c(age, sex, condition, team,
                                      groupClickPostFactor, groupBondingFactorPost, teamBondingFactorPost))

  ##rename columns for tables:
  library(dplyr)
  twcClickBondPost <- dplyr::rename(twcClickBondPost, Team = team, Condition = condition,
                                      Sex = sex, Age = age, GroupClickPost = groupClickPostFactor,
                                      GroupBondingPost =  groupBondingFactorPost,
                                      TeamBondingPost = teamBondingFactorPost)

  ## create a variable list which we want in table one
  listVars <- c("GroupClickPost", "GroupBondingPost", "TeamBondingPost")

  ## define categorical variables
  catVars <- c("Condition")

  ## Create overall table:
  table1 <- CreateTableOne(vars = listVars,
                           strata = "Condition",
                           data = twcClickBondPost,
                           factorVars = catVars,
                           test = FALSE
                           )

  ## create table which is printable
  table1_overall <- print(table1,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )
  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(table1_overall, type="latex",
                      caption = "Athlete perceptions of click and bonding \n post-experiment",
                      label = "tab:clickBondConditionPost"),
                      file="clickBondConditionPost.tex")
@


<<factorsByCondition, eval=T,echo=F>>=
  ## Compile the following factors:
  ##PERFORMANCE(4):
        # indPerformanceFactor (components) (t1,2,3)
        # jointActionSuccess (t2,3)
        # team jointActionSuccess (t1)
        # indPerformance_1, 2 (how are you feeling about performacen overall) (this is not needed)
        # indPerformance_3(expectations t3)
        # groupPerformance_3(expectations, t3 only)
  ##CLICK:
        # groupClick
  ##BONDING:
        # groupBonding
        # teamBonding
  ##AROUSAL:


  ## First get all variables, then subset by condition
  #separate tlc$indPerformance into t1,2 and then t3 (vs expectations):
  tlc$indPerformanceExpectations <- twc$indPerformance_3
  tlc$indPerformanceExpectations[tlc$time == 2] <- NA
  tlc$indPerformanceExpectations[tlc$time == 1] <- NA
  #rename groupPerformance as groupPerformanceExpectations and rescale:
  tlc$groupPerformanceExpectations <- tlc$groupPerformance
  #rescale ind and group performance expectations
  library(scales)
  tlc$groupPerformanceExpectations[tlc$time == 3] <- scales::rescale(tlc$groupPerformanceExpectations[tlc$time == 3],
                                                                     to = c(0, 100))
  # tlcGroupPerformance$groupPerformanceExp[tlcGroupPerformance$time == 3] <- rescale(tlcGroupPerformance$groupPerformanceExp[tlcGroupPerformance$time == 3],
    #                                                                                    to = c(0, 100),
    #                                                                                    from = c(-50, 50))

  #tlc$indPerformanceExpectations[tlc$time == 3] <- scales::rescale(tlc$indPerformanceExpectations[tlc$time == 3],
                                                                   to = c(0, 100))
  tlc$indPerformance[tlc$time == 3] <- NA

  tlcFactors <- subset(tlc, select = c(age, sex, condition, team, time, jointActionSuccess,
                                        indPerformanceFactor, groupPerformanceExpectations, indPerformanceExpectations,
                                        groupClickFactor1, groupClickPostFactor, groupBondingFactor, teamBondingFactor, arousalFactor))

  ## rename values for factors:
  tlcFactors$sex <- ifelse(!is.na(tlcFactors$sex) & tlcFactors$sex == 0, "male",
                                      ifelse(!is.na(tlcFactors$sex) & tlcFactors$sex == 1, "female", NA))


  tlcFactors$time <- ifelse(!is.na(tlcFactors$time) &
                                    tlcFactors$time == 3, "Post",
                                  ifelse(!is.na(tlcFactors$time) &     tlcFactors$time == 2, "Pre",
                                  ifelse(!is.na(tlcFactors$time) & tlcFactors$time == 1, "Baseline", NA)))
  tlcFactors$time <- factor(tlcFactors$time, levels = c("Baseline", "Pre",
                                    "Post"), ordered = is.ordered(tlcFactors$time))

  tlcFactors$team <- ifelse(!is.na(tlcFactors$team) & tlcFactors$team ==
                                          "bjm","Beijing Men", ifelse(!is.na(tlcFactors$team) & tlcFactors$team == "bjw", "Beijing Women",
                                          ifelse(!is.na(tlcFactors$team) & tlcFactors$team == "sdm", "Shandong Men",
                                          ifelse(!is.na(tlcFactors$team) & tlcFactors$team == "sdw", "Shandong Women", NA))))

  ##rename columns for tables:
  library(dplyr)
  tlcFactors <- dplyr::rename(tlcFactors, Team = team, Condition = condition, Sex = sex,
                                          Time = time,
                                          Age = age, JointActionSuccess = jointActionSuccess,
                                          IndividualComponentPerformance = indPerformanceFactor, GroupPerformVsExpected = groupPerformanceExpectations,
                                          IndividualPerformanceExpectations = indPerformanceExpectations, GroupClick = groupClickFactor1,
                                          GroupClickPost = groupClickPostFactor, GroupBonding = groupBondingFactor,
                                          TeamBondingFactor = teamBondingFactor, Arousal = arousalFactor)
  ## subset high and low conditions:

  tlcFactorsHigh <- subset(tlcFactors, Condition == "high")
  tlcFactorsLow <- subset(tlcFactors, Condition == "low")

  t.test(tlcFactorsHigh$GroupClick, tlcFactorsLow$GroupClick, na.rm=T)

  ## create a variable list which we want in table one
  listVars <- c("JointActionSuccess", "IndividualComponentPerformance",
                                      "GroupPerformVsExpected", "IndividualPerformanceExpectations",
                                      "GroupClick", "GroupBonding", "GroupClickPost", "TeamBondingFactor", "Arousal")

  ## define categorical variables
  catVars <- c("Sex", "Team", "Time")


  ## Create high difficulty condition table table:
  tableFactorsHigh <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcFactorsHigh,
                           factorVars = catVars,
                           test = FALSE
                           )

  ## create table which is printable
  table_overall <- print(tableFactorsHigh,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(table_overall, type="latex",
                      caption = "Variables of interest \n high difficulty condition",
                      label = "tab:factorsTimeHigh"),
                      file="factorsTimeHigh.tex")



  ## create table one for low difficulty condition, strata = Condition
  tableFactorsLow <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcFactorsLow,
                           factorVars = catVars,
                           test = FALSE
                           )

  ## create table which is printable
  table1_overall <- print(tableFactorsLow,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(table1_overall, type="latex",
                      caption = "Variables of interest \n low difficulty condition",
                      label = "tab:factorsTimeLow"),
                      file="factorsTimeLow.tex")


  #Factors by condition:
  tableFactorsCondition <- CreateTableOne(vars = listVars,
                                 strata = "Condition",
                                 data = tlcFactors,
                                 factorVars = catVars,
                                 test = FALSE
                                 )

  table1_overall <- print(tableFactorsCondition,
                                 quote = FALSE,
                                 noSpaces = FALSE,
                                 printToggle = FALSE
                                 )
  print(xtable(table1_overall, type="latex",
                                 caption = "Variables of interest \n by condition",
                                 label = "tab:factorsTimeLow"),
                                 file="factorsCondition.tex")
@

There were also no observable differences in group click, group bonding, or bonding to team following the experiment (see Tables ~\ref{tab:clickBondConditionPost}\nobreakdash~\ref{tab:factorsTimeLow}).  These results suggest that there was no observable variaiton in athlete self-report according to condition.  Given these results, the entire experiment sample was collapsed into one group and study predictions were tested in this group as a whole.

<<collapseSampleByTime, eval=T,echo=F>>=
  ## Create high difficulty condition table table:
  tableFactors <- CreateTableOne(vars = listVars,
                           strata = "Time",
                           data = tlcFactors,
                           factorVars = catVars,
                           smd = T,
                           test = FALSE
                           )

  ## create table which is printable
  table_overall <- print(tableFactors,
                              quote = FALSE,
                              noSpaces = FALSE,
                              printToggle = FALSE
                              )

  ## print to latex file in wd
  ## this latex file will later be inputted
  print(xtable(table_overall, type="latex",
                      caption = "Variables of interest over time \n for entire sample",
                      label = "tab:factorsTime"),
                      file="factorsTime.tex")
@

\input{/Users/jacob1/Documents/2017/Research/DPhil/Dissertation/finalDocuments/jointActionSocialBonding/images/factorsTime.tex}

Table ~\ref{tab:factorsTime} shows that the post-Experiment measures of Joint Action Success and Team Click were significantly lower than pre-Experiment measurements.  Group Bonding also appeared to reduce, between pre- and post-Experiment measures,  but this change was not significant.  Athlete reports of arousal significantly increased following the experiment, as would be expected due to the moderate to high levels of physiological exertion associated with the training drill.  Athlete perceptions of components of individual performance and bonding to the team as a whole did not vary significantly acrross time points.




<<conditionGroupPerf, eval=T, echo=F>>=
summary(conditionGroupPerf.main <- lmer(groupPerformance_3 ~ condition
                            + (1|sessionName)
                            , data = twc
                            , REML = F
                          )
                        )

summary(conditionGroupPerf.controls <- lmer(groupPerformance_3 ~ condition
                            + indPerformance_3Norm + arousalFactorPost + fullOutcomeAvg
                            + subjectiveCompetenceFactor + objectiveCompetenceFactor
                            + (1 |sessionName)
                            , data = twc
                            , REML = F
                        )
                      )

@









\subsection{Analysis of Study Predictions}



\subsubsection{Post-Experiment Survey Data}

Study predictions were tested using the post-Experiment survey data.  Intra-class correlation estimates were calculated in order to account for the possibility of clustering of model residuals according to groupings of athlete sex, team, experiment location and specific experiment session (see Table ~\ref{tab:ICCTable}). ICC values indicated that between-group variance was low to moderate, with highest values for feelings of group click and social bonding between teams and experimental sessions. Given the constraints on model complexity imposed by the relatively small sample size of the study, experimental session was chosen as a level 2 grouping variable. High variation in the mean and standard deviation of objective performance outcome (see Figure ~\ref{fig:fullOutcomeAvgSessionBoxplot}) further supported the decision to account for variation attributable to experiment session. Consistent with the previous study, a linear mixed effects regression (LMER) model (package ``lme4'' in the R environment) was used to test relationships between variables of interest (see Ch5 Section X).


<<ICCestimatesSession, eval=T, echo=F>>=

t.test(twc$trainingAge[twc$condition == "high"], twc$trainingAge[twc$condition == "low"], na=T)
sd(twc$trainingAge[twc$condition == "high"], na=T)
sd(twc$trainingAge[twc$condition == "low"], na=T)

mean(twc$groupPerformance_3[twc$condition == "high"], na.rm=T)
sd(twc$groupPerformance_3[twc$condition == "high"], na.rm=T)
mean(twc$groupPerformance_3[twc$condition == "low"], na.rm=T)
sd(twc$groupPerformance_3[twc$condition == "low"], na.rm=T)

#success total
mean(twc$successTotals[twc$condition == "high"], na.rm=T)
sd(twc$successTotals[twc$condition == "high"], na.rm=T)
mean(twc$successTotals[twc$condition == "low"], na.rm=T)
sd(twc$successTotals[twc$condition == "low"], na.rm=T)

#outcome avg
mean(twc$fullOutcomeAvg[twc$condition == "high"], na.rm=T)
sd(twc$fullOutcomeAvg[twc$condition == "high"], na.rm=T)
mean(twc$fullOutcomeAvg[twc$condition == "low"], na.rm=T)
sd(twc$fullOutcomeAvg[twc$condition == "low"], na.rm=T)


library(ICC)
  # groupConfidence
   groupConfidenceICC <- ICCest(sessionName, groupConfidentTechnicalChallenges_2 , data = twc, CI.type = "THD")

  #indConfidence
  indConfidenceICC <- ICCest(sessionName, indConfidenceChallenges_2 , data = twc, CI.type = "THD")

  #arousal

    arousalICC <- ICCest(sessionName, arousalFactorPre , data = twc, CI.type = "THD")

  # performance
  performanceSessionICC <- ICCest(sessionName, groupPerformance_3Norm, data = twc, CI.type = "THD") #  0.06428764  / 7.102757 (k - unbalanced score)
  groupClickSessionICC <- ICCest(sessionName, groupClickPostFactor, data = twc, CI.type = "THD") #  0.1415473  / 7.102757 (k - unbalanced score)
  # there is only one observation per group for fullOutcomeAvg, so ICC will = 1 (F test is a ratio):
  groupBondingSessionICC <- ICCest(sessionName, groupBondingFactorPost, data = twc, CI.type = "THD") #  0.2146226  / 7.102757(k - unbalanced score)
  fullOutcomeAvgSessionICC <- ICCest(sessionName, fullOutcomeAvg, data = twc, CI.type = "THD")
  #    1 / 7.226601(k - unbalanced score)
@


<<ICCestimatesSex, eval=T, echo=F>>=
  twc$sex <- as.factor(twc$sex)
  #performance
  performanceSexICC <- ICCest(sex, groupPerformance_3Norm, data = twc, CI.type = "THD") #  0.06424739  / 28.42105 (k - unbalanced score)
  #click
  groupClickSexICC <- ICCest(sex, groupClickPostFactor, data = twc, CI.type = "THD") #  -0.03188563  / 28.42105(k - unbalanced score)
  #bonding
  groupBondingSexICC <- ICCest(sex, groupBondingFactorPost, data = twc, CI.type = "THD") #  -0.0113713  / 28.42105 (k - unbalanced score)
  fullOutcomeAvgSexICC <- ICCest(sex, fullOutcomeAvg, data = twc, CI.type = "THD")
  #    -0.009384193 / 28.86207(k - unbalanced score)
@

<<ICCestimatesTeam, eval=T, echo=F>>=
  #performance
  performanceTeamICC <- ICCest(team, groupPerformance_3Norm, data = twc, CI.type = "THD") # 0.07940202  / 28.42105 (k - unbalanced score)
  #click
  groupClickTeamICC <- ICCest(team, groupClickPostFactor, data = twc, CI.type = "THD") #   0.08523601 / 14.16374(k - unbalanced score)
  #bonding
  groupBondingTeamICC <- ICCest(team, groupBondingFactorPost, data = twc, CI.type = "THD") #  0.2366225 / 14.16374 (k - unbalanced score)
  fullOutcomeAvgTeamICC <- ICCest(team, fullOutcomeAvg, data = twc, CI.type = "THD")
  #    0.2969028  / 14.4023 (k - unbalanced score)
@

<<ICCestimatesLocation, eval=T, echo=F>>=
  twc$sessionLocation <- twc$team
  twc$sessionLocation <- ifelse(twc$team == "bjm" | twc$team == "bjw", "beijing",
                                "shandong")
  twc$sessionLocation <- as.factor(twc$sessionLocation)
  #performance
  performanceSessionLocationICC <- ICCest(sessionLocation, groupPerformance_3Norm, data = twc, CI.type = "THD") # 0.009442271  / 28.2807 (k - unbalanced score)
  #click
  groupClickSessionLocationICC <- ICCest(sessionLocation, groupClickPostFactor, data = twc, CI.type = "THD") #   0.07621335 / 28.2807 (k - unbalanced score)
  #bonding
  groupBondingSessionLocationICC <- ICCest(sessionLocation, groupBondingFactorPost, data = twc, CI.type = "THD") #    0.1493902  / 28.2807 (k - unbalanced score)
  #ObjectivePerformanceOutcome
  fullOutcomeAvgSessionLocationICC <- ICCest(sessionLocation, fullOutcomeAvg, data = twc, CI.type = "THD") #    0.3844965  / 28.2807 (k - unbalanced score)
@

<<ICCTable, eval=T, echo=F, fig.cap="">>=
  ##create variables (columns):
  variable <- c("PerformExpected", "GroupClick", "GroupBonding")
  session <- as.numeric(c(performanceSessionICC$ICC,
                                groupClickSessionICC$ICC, groupBondingSessionICC$ICC))
  sex <- as.numeric(c(performanceSexICC$ICC, groupClickSexICC$ICC,
                                groupBondingSexICC$ICC))
  team <- as.numeric(c(performanceTeamICC$ICC, groupClickTeamICC$ICC,
                                groupBondingTeamICC$ICC))
  location <- as.numeric(c(performanceSessionLocationICC$ICC,
                                groupClickSessionLocationICC$ICC,
                                groupBondingSessionLocationICC$ICC))
  ICCTable <- data.frame(variable, session, sex, team, location)
  # round to 2dp
  ICCTable[,-1] <- round(ICCTable[,-1],2)

  ICCTable <- xtable(ICCTable,
                        caption = "Intra class correlations of variables of interest according to groups",
                        label = "tab:ICCTable")
  align(ICCTable) <- "rrcccc"
  print(ICCTable, file="ICCTable.tex")
@

<<fullOutcomeAvgSD, eval=T,echo=F, fig.cap="">>=
  ## create df for fullOutcomeAvg & outcomeSD:

  ##rename columns for tables:
  outcomeDf <- subset(twc, select = c(condition, team, sessionName, fullOutcomeAvg, fullOutcomeSd))


  outcomeDf <- dplyr::rename(outcomeDf, Condition = condition, Team = team,
                                  Session = sessionName,
                                  AverageOutcome = fullOutcomeAvg, StandardDeviation = fullOutcomeSd)

  ### Create table with avg outcome and sd
  Session <- as.factor(c("ShandongWomenHigh", "ShandongMenHigh",
                          "BeijingWomenHigh", "BeijingMenHigh","ShandongWomenLow",
                          "ShandongMenLow", "BeijingWomenLow", "BeijingMenLow"))


  AverageOutcome <- as.numeric(c(outcomeDf$AverageOutcome[outcomeDf$Session == "sdwB"],
                        outcomeDf$AverageOutcome[outcomeDf$Session == "sdmB"],
                        outcomeDf$AverageOutcome[outcomeDf$Session == "bjwB"],
                        outcomeDf$AverageOutcome[outcomeDf$Session == "bjmB"],
                        outcomeDf$AverageOutcome[outcomeDf$Session == "sdwA"],
                        outcomeDf$AverageOutcome[outcomeDf$Session == "sdmA"],
                        outcomeDf$AverageOutcome[outcomeDf$Session == "bjwA"],
                        outcomeDf$AverageOutcome[outcomeDf$Session == "bjmA"])
                      )

  AverageOutcomeSession <- AverageOutcome[c(1,9,17,25,32,40,48,54)]
  Mean <- AverageOutcomeSession

  StandardDeviation <- as.numeric(c(outcomeDf$StandardDeviation[outcomeDf$Session ==
                        "sdwB"],
                        outcomeDf$StandardDeviation[outcomeDf$Session == "sdmB"], outcomeDf$StandardDeviation[outcomeDf$Session == "bjwB"],
                        outcomeDf$StandardDeviation[outcomeDf$Session == "bjmB"],
                        outcomeDf$StandardDeviation[outcomeDf$Session == "sdwA"],
                        outcomeDf$StandardDeviation[outcomeDf$Session == "sdmA"],
                        outcomeDf$StandardDeviation[outcomeDf$Session == "bjwA"],
                        outcomeDf$StandardDeviation[outcomeDf$Session == "bjmA"])
                        )

  StandardDeviationSession <- StandardDeviation[c(1,9,17,25,32,40,48,54)]
  SD <- StandardDeviationSession

  outcomeSession1 <- data.frame(Session, Mean, SD)

  print(xtable(outcomeSession1, type="latex",
                         caption = "Mean and standard deviation of performance outcome according to experiment session",
                         label = "tab:fullOutcomeAvgSdSession"),
                         file="fullOutcomeAvgSdSession.tex")
@
<<fullOutcomeAvgSessionBoxplot, eval=T,echo=F, fig.cap="">>=
  ##order experiment session to align with table above:
  outcomeDf$Session <- factor(outcomeDf$Session, levels = c("sdwB",
                              "sdmB","bjwB","bjmB", "sdwA", "sdmA", "bjwA", "bjmA"),
                                  ordered = is.ordered(outcomeDf$Session))

  outcomeDf$Session <- plyr::revalue(outcomeDf$Session, c("sdwB" = "sdwH",
                                                    "sdmB" = "sdmH",
                                                    "bjwB" = "bjwH", "bjmB" = "bjmH",
                                                    "sdwA" = "sdwL",  "sdmA" = "sdmL",
                                                    "bjwA" = "bjwL", "bjmA" = "bjmL"))

  fullOutcomeAvgSdSessionBox <- ggplot(outcomeDf,
                            aes(x=Session, y=AverageOutcome, size=StandardDeviation)) +
                            geom_boxplot() +
                            ggtitle(element_blank()) +
                            labs(x = "Experiment Session",
                                 y = "Average Performance Outcome") +
                            ylab("Average Performance Outcome") +
                            scale_linetype_discrete(name='SD') +
                            apatheme
  fullOutcomeAvgSdSessionBox
@


<<conditionResultsPostDrill, echo=F,eval=T>>=
  twc$condition <- factor(twc$condition, ordered = FALSE)

# groupPerformance:
          summary(conditionGroupPerfPost <- lmer(groupPerformance_3Norm ~ condition
                                                  + arousalFactorPost
                                                  + fullOutcomeAvg
                                                  + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                                  + tipiExtraverted
                                                  + ( 1 |sessionName),
                                                    data = twc,
                                                    REML = F)
                )
        conditionGroupPerfPost.CIs <- confint.merMod(conditionGroupPerfPost, method = "Wald", level = 0.95)

#groupComponentsSuccess (jAS):
        summary(conditionJASPost <- lmer(jointActionSuccessPost ~ condition
                                          + arousalFactorPost
                                          + fullOutcomeAvg
                                          + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                          + tipiExtraverted
                                          + ( 1 |sessionName),
                                            data = twc,
                                            REML = F)
                                  )
  conditionJASPost.CIs <- confint.merMod(conditionJASPost, method = "Wald", level = 0.95)

#indPerformance_3Norm
      summary(conditionIndPerfPost <- lmer(indPerformance_3Norm ~ condition
                                        + arousalFactorPost
                                        + fullOutcomeAvg
                                        + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                        + tipiExtraverted
                                        + ( 1 |sessionName),
                                          data = twc,
                                          REML = F)
                                        )
      conditionIndPerfPost.CIs <- confint.merMod(conditionIndPerfPost, method = "Wald", level = 0.95)

#indComponentsPerformance/indvidualComponentSuccess

#summary(conditionIndPerfComponentsPost <- lmer(indPerformanceComponentsPost ~ condition
  #                                + arousalFactorPost
  #                                + fullOutcomeAvg
  #                                + subjectiveCompetenceFactor + objectiveCompetenceFactor
  #                                + tipiExtraverted
  #                                + ( 1|sessionName),
  #                                  data = twc,
  #                                  REML = F)
  #                                )

#conditionIndPerfComponentsPost.CIs <- confint.merMod(conditionIndPerfComponentsPost, method = "Wald", level = 0.95)








#teamClick
    summary(conditionClickPost <- lmer(groupClickPostFactor ~ condition
                                            + arousalFactorPost
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                            + tipiExtraverted
                                            + ( 1 |sessionName),
                                              data = twc,
                                              REML = F)
          )
    conditionClickPost.CIs <- confint.merMod(conditionClickPost, method = "Wald", level = 0.95)

#groupBonding
    summary(conditionBondingPost <- lmer(groupBondingFactorPost ~ condition
                                            + arousalFactorPost
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                            + tipiExtraverted
                                            + ( 1 |sessionName),
                                              data = twc,
                                              REML = F)
          )
      conditionBondingPost.CIs <- confint.merMod(conditionBondingPost, method = "Wald", level = 0.95)


#team(Squad)Bonding
summary(conditionBondingPost <- lmer(teamBondingFactorPost ~ condition
                                        + arousalFactorPost
                                        + fullOutcomeAvg
                                        + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                        + tipiExtraverted
                                        + ( 1 |sessionName),
                                          data = twc,
                                          REML = F)
      )
  conditionBondingPost.CIs <- confint.merMod(conditionBondingPost, method = "Wald", level = 0.95)




  #confint:
  #groupPerfExpClick.controls.CIs <- confint.merMod(groupPerfExpClick.controls, method = "Wald", level = 0.95)
  #calculate marginal (fixed) and conditional (random) R^2 for the model:
  #groupPerfExpClick.controls.R2 <- sem.model.fits(groupPerfExpClick.controls)

#install.packages("lsmeans")
#  library(lmerTest)
  #library(lsmeans)
  #lsmip(groupPerfExpClick.controls, groupPerformance_3Norm ~ condition)

@






\subsubsection{Analysis of pre- and post-Experiment survey data}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
PRE-POST ANALYSIS:
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
1. pre-post changes:
  i. performance expectations?
  ii. click?
  iii. bonding?



<<prePostPrepareData, eval=T,echo=F>>=

  #groupPerformance needs to be re-sacled with min = 0, and then converted to a z-score with mean = 0:
 library(scales)
  tlc$groupPerformance <- scales::rescale(tlc$groupPerformance, to = c(0, 100))
  tlc$indPerformance[tlc$time == 3] <- scales::rescale(tlc$indPerformance[tlc$time == 3], to = c(0, 100))

#hist(tlc$groupPerformance)
  #  tlc$groupPerformanceNorm <- scale(tlc$groupPerformance)
  #  tlc$indPerformanceNorm <- scale(tlc$indPerformance)


#tlc$groupPerformanceFactor # this is component performance, measured at T2 and T3
twc$condition <- factor(twc$condition, levels = c("low", "high"))


@



<<groupPerfPrePostVariable, eval=T,echo=F>>=
  ## Create new variable containing groupPerformanceExpectations (t = 3) and confidence in group performance (t=2).  A discrepancy between these two will be calculated:
  tlc$groupPerfConfExp[tlc$time == 3] <-  tlc$groupPerformance[tlc$time == 3]
  tlc$groupPerfConfExp[tlc$time == 2] <- tlc$groupConfidentTechnicalChallenges[tlc$time == 2]
  ##standardise groupPerformancePrePost in order to align with other predictor variable factors:
  tlc$groupPerfConfExpNorm <- scale(tlc$groupPerfConfExp)

# do the same for ind Performance confidence and expectations
  tlc$indPerfConfExp[tlc$time == 3] <- tlc$indPerformanceExpectations[tlc$time == 3]
  tlc$indPerfConfExp[tlc$time == 2] <- tlc$indConfidenceChallenges[tlc$time == 2]
  ##standardise indPerformancePrePost in order to align with other predictor variable factors:
  tlc$indPerfConfExpNorm <- scale(tlc$indPerfConfExp)
@


<<prePostPrepareHighLow, eval=T,echo=F>>=
lowLong <- subset(tlc, condition == "low")
highLong <- subset(tlc, condition == "high")
@


<<groupPerfConfPlot, eval=T,echo=F>>=
library(tidyverse)
tlc$time <- as.factor(tlc$time)
groupPerfConfExpBox <- ggplot(tlc,
                aes(x=time, y=groupPerfConfExpNorm)) +
                geom_boxplot() +
                facet_wrap(~condition) +
                labs(x = "Time", y = "Group Performance") +
                apatheme +
                ggsave("groupPerfConfPlot.pdf")
groupPerfConfExpBox
@



<<groupPerfConfExpModel, eval=T,echo=F>>=
  ##is there a change in this variable over time?
  summary(groupPerfConfExpPrePost.lmer <- lmer(groupPerfConfExpNorm ~ time
                                      + (1 | englishName)
                                      , data = tlc
                                      , REML = FALSE
                                  )
          )

  ## interaction with condition? <- doesn't look like it
  summary(groupPerfPrePostCondition.lmer <- lmer(groupPerfConfExpNorm ~
                                                time*condition
                                      + (1 | englishName)
                                      + (1 | sessionName)
                                      , data = tlc
                                      , REML = FALSE
                                  )
          )
      groupPerfPrePostCondition.lmer.CIs <- confint.merMod(groupPerfPrePostCondition.lmer, method = "Wald", level = 0.95)
@



<<prePostClickPlot, eval=T,echo=F, fig.cap= "Pre- and post-Experiment measures of group click">>=
## use groupClickFactor1, has both time points:

  clickPPBox <- ggplot(tlc,
                          aes(x=time, y=groupClickFactor1)) +
                          geom_boxplot() +
                          facet_wrap(~condition) +
                          labs(x = "Time", y = "Team Click") +
                          apatheme +
                          ggsave("prePostClickPLot.pdf")
  clickPPBox
@


<<clickPrePostModel, eval=T,echo=F>>=
  ##is there a change in this variable over time?
  summary(clickPrePost.lmer <- lmer(groupClickFactor1 ~ time
                                      + (1 | englishName)
                                      + (1 | sessionName)
                                      , data = tlc
                                      , REML = FALSE
                                  )
          )
  ## interaction with condition? <- doesn't look like it
  summary(clickPrePostCondition.lmer <- lmer(groupClickFactor1 ~ time*condition
                                      + (1 | englishName)
                                      + (1 | sessionName)
                                      , data = tlc
                                      , REML = FALSE
                                  )
          )

clickPrePostCondition.lmer.CIs <- confint.merMod(clickPrePostCondition.lmer, method = "Wald", level = 0.95)
@


<<prePostBondingPlot, eval=T,echo=F, fig.cap= "Pre- and post-Experiment measures of group Bonding">>=
## use groupBondingFactor, has both time points:
  bondingPPBox <- ggplot(tlc,
                          aes(x=time, y=groupBondingFactor)) +
                          geom_boxplot() +
                          facet_wrap(~condition) +
                          labs(x = "Time", y = "Group Bonding") +
                          apatheme +
                          ggsave("prePostBondingPlot.pdf")
  bondingPPBox
@


<<bondingPrePostModel, eval=T,echo=F>>=
  ##is there a change in this variable over time?
  summary(bondingPrePost.lmer <- lmer(groupBondingFactor ~ time
                                      + (1 | englishName)
                                      + (1 | sessionName)
                                      , data = tlc
                                      , REML = FALSE
                                  )
          )
  ## interaction with condition? <- doesn't look like it
  summary(bondingPrePostCondition.lmer <- lmer(groupBondingFactor ~ time*condition
                                      + (1 | englishName)
                                      + (1 | sessionName)
                                      , data = tlc
                                      , REML = FALSE
                                  )
          )

bondingPrePostCondition.lmer.CIs <- confint.merMod(bondingPrePostCondition.lmer, method = "Wald", level = 0.95)

@







<<prePostVariables, eval=T,echo=F>>=
#create pre-post Variables:
#groupPerformance
tlc$groupPerfChangePrePost <- tlc$groupPerformanceExpectations[tlc$time == 3] - tlc$groupConfidentTechnicalChallenges[tlc$time == 2]
#tlc$groupPerfChangePrePostNorm <- scale(tlc$groupPerfChangePrePost)
hist(tlc$groupPerfChangePrePost[tlc$time == 3]
                  , main = NA
                  , xlab = "Change in group performance"
              )
              dev.copy(pdf, "groupPerfChangeHist.pdf")
              dev.off()

#indPerformance   tlc$indPerfConfExpNorm
tlc$indPerfChangePrePost <- tlc$indPerfConfExp[tlc$time == 3] - tlc$indPerfConfExp[tlc$time == 2]
#tlc$indPerfExpChangePrePostNorm <- scale(tlc$indPerfChangePrePost)
hist(tlc$indPerfChangePrePost[tlc$time == 3]
                                        , main = NA
                                        , xlab = "Change in individual performance"
                                      )

                                    dev.copy(pdf, "indPerfChangeHist.pdf")
                                    dev.off()

#groupClick groupClickFactor1
tlc$groupClickChangePrePost <- tlc$groupClickFactor1[tlc$time == 3] - tlc$groupClickFactor1[tlc$time == 2]
#tlc$groupClickChangePrePostNorm <- scale(tlc$groupClickChangePrePost)
hist(tlc$groupClickChangePrePost[tlc$time == 3]
                                      , main = NA
                                      , xlab = "Change in group click"
                                    )

                                    dev.copy(pdf, "groupClickChangeHist.pdf")
                                    dev.off()

#groupClick groupClickFactor1
tlc$groupBondingChangePrePost <- tlc$groupBondingFactor[tlc$time == 3] - tlc$groupBondingFactor[tlc$time == 2]
#tlc$groupBondingChangePrePostNorm <- scale(tlc$groupBondingChangePrePost)
hist(tlc$groupBondingChangePrePost[tlc$time == 3]
                                      , main = NA
                                      , xlab = "Change in group bonding"
                                    )

                              dev.copy(pdf, "groupBondingChangeHist.pdf")
                              dev.off()

# teamBonding
tlc$teamBondingChangePrePost <- tlc$teamBondingFactor[tlc$time == 3] - tlc$teamBondingFactor[tlc$time == 1]
hist(tlc$teamBondingChangePrePost[tlc$time == 3]
                                      , main = NA
                                      , xlab = "Change in team bonding"
                                    )

                              dev.copy(pdf, "teamBondingChangeHist.pdf")
                              dev.off()

#attach variables to wide df (twc):
twc$groupPerfChangePrePost <- tlc$groupPerfChangePrePost[tlc$time == 3]
twc$indPerfChangePrePost <- tlc$indPerfChangePrePost[tlc$time == 3]
twc$groupClickChangePrePost <- tlc$groupClickChangePrePost[tlc$time == 3]
twc$groupBondingChangePrePost <- tlc$groupBondingChangePrePost[tlc$time == 3]
twc$teamBondingChangePrePost <- tlc$teamBondingChangePrePost[tlc$time == 3]
@

<<exploreRelationshipsPrePost, eval=T,echo=F>>=
plot(twc$groupPerfChangePrePost, twc$groupClickChangePrePost)
plot(twc$groupClickChangePrePost, twc$groupBondingChangePrePost)
plot(twc$groupPerfChangePrePost, twc$groupBondingChangePrePost)
@

<<normalisePrePostMeasures, eval=T,echo=F>>=
#normalise all variables:
twc$groupPerfChangePrePostNorm <- scale(twc$groupPerfChangePrePost)
twc$indPerfChangePrePostNorm <- scale(twc$indPerfChangePrePost)
twc$groupClickChangePrePostNorm <- scale(twc$groupClickChangePrePost)
twc$groupBondingChangePrePostNorm <- scale(twc$groupBondingChangePrePost)
twc$teamBondingChangePrePostNorm <- scale(twc$teamBondingChangePrePost)

@



<<ICCestimatesPrePostSession, eval=T, echo=F>>=
  # performance
  performanceSessionPrePostICC <- ICCest(sessionName, groupPerfChangePrePostNorm, data = twc, CI.type = "THD") #  0.06428764  / 7.102757 (k - unbalanced score)
  groupClickSessionPrePostICC <- ICCest(sessionName, groupClickChangePrePostNorm, data = twc, CI.type = "THD") #  0.1415473  / 7.102757 (k - unbalanced score)
  # there is only one observation per group for fullOutcomeAvg, so ICC will = 1 (F test is a ratio):
  groupBondingSessionPrePostICC <- ICCest(sessionName, groupBondingChangePrePostNorm, data = twc, CI.type = "THD") #  0.2146226  / 7.102757(k - unbalanced score)
  teamBondingSessionPrePostICC <- ICCest(sessionName, teamBondingChangePrePostNorm, data = twc, CI.type = "THD")
  #fullOutcomeAvgSessionPrePostICC <- ICCest(sessionName, fullOutcomeAvg, data = twc, CI.type = "THD")
  #    1 / 7.226601(k - unbalanced score)
@


<<ICCestimatesPrePostSex, eval=T, echo=F>>=
  twc$sex <- as.factor(twc$sex)
  #performance
  # performance
  performanceSexPrePostICC <- ICCest(sex, groupPerfChangePrePostNorm, data = twc, CI.type = "THD") #  0.06428764  / 7.102757 (k - unbalanced score)
  groupClickSexPrePostICC <- ICCest(sex, groupClickChangePrePostNorm, data = twc, CI.type = "THD") #  0.1415473  / 7.102757 (k - unbalanced score)
  # there is only one observation per group for fullOutcomeAvg, so ICC will = 1 (F test is a ratio):
  groupBondingSexPrePostICC <- ICCest(sex, groupBondingChangePrePostNorm, data = twc, CI.type = "THD") #  0.2146226  / 7.102757(k - unbalanced score)
  teamBondingSexPrePostICC <- ICCest(sex, teamBondingChangePrePostNorm, data = twc, CI.type = "THD")
  #fullOutcomeAvgSessionPrePostICC <- ICCest(sex, fullOutcomeAvg, data = twc, CI.type = "THD")
  #    1 / 7.226601(k - unbalanced score)

  #fullOutcomeAvgSexPrePostICC <- ICCest(sex, fullOutcomeAvg, data = twc, CI.type = "THD")
  #    -0.009384193 / 28.86207(k - unbalanced score)
@

<<ICCestimatesPrePostTeam, eval=T, echo=F>>=
  #performance
  performanceTeamPrePostICC <- ICCest(team, groupPerfChangePrePostNorm, data = twc, CI.type = "THD") #  0.06428764  / 7.102757 (k - unbalanced score)
  groupClickTeamPrePostICC <- ICCest(team, groupClickChangePrePostNorm, data = twc, CI.type = "THD") #  0.1415473  / 7.102757 (k - unbalanced score)
  # there is only one observation per group for fullOutcomeAvg, so ICC will = 1 (F test is a ratio):
  groupBondingTeamPrePostICC <- ICCest(team, groupBondingChangePrePostNorm, data = twc, CI.type = "THD") #  0.2146226  / 7.102757(k - unbalanced score)
  teamBondingTeamPrePostICC <- ICCest(team, teamBondingChangePrePostNorm, data = twc, CI.type = "THD")
  #fullOutcomeAvgTeamPrePostICC <- ICCest(team, fullOutcomeAvg, data = twc, CI.type = "THD")
  #    1 / 7.226601(k - unbalanced score)
@

<<ICCestimatesPrePostLocation, eval=T, echo=F>>=
  twc$sessionLocation <- twc$team
  twc$sessionLocation <- ifelse(twc$team == "bjm" | twc$team == "bjw", "beijing",
                                "shandong")
  twc$sessionLocation <- as.factor(twc$sessionLocation)
  #performance:
  performanceLocationPrePostICC <- ICCest(sessionLocation, groupPerfChangePrePostNorm, data = twc, CI.type = "THD") #  0.06428764  / 7.102757 (k - unbalanced score)
  groupClickLocationPrePostICC <- ICCest(sessionLocation, groupClickChangePrePostNorm, data = twc, CI.type = "THD") #  0.1415473  / 7.102757 (k - unbalanced score)
  # there is only one observation per group for fullOutcomeAvg, so ICC will = 1 (F test is a ratio):
  groupBondingLocationPrePostICC <- ICCest(sessionLocation, groupBondingChangePrePostNorm, data = twc, CI.type = "THD") #  0.2146226  / 7.102757(k - unbalanced score)
  teamBondingLocationPrePostICC <- ICCest(sessionLocation, teamBondingChangePrePostNorm, data = twc, CI.type = "THD")
  #fullOutcomeAvgSessionPrePostICC <- ICCest(sessionLocation, fullOutcomeAvg, data = twc, CI.type = "THD")
@

<<ICCTablePrePost, eval=T, echo=F, fig.cap="">>=
  ##create variables (columns):
  variable <- c("ChangePerformExpected", "ChangeGroupClick", "ChangeGroupBonding", "ChangeTeamBonding")
  session <- as.numeric(c(performanceSessionPrePostICC$ICC
                                      , groupClickSessionPrePostICC$ICC
                                      , groupBondingSessionPrePostICC$ICC
                                      , teamBondingSessionPrePostICC$ICC
                                    )
                                  )
  sex <- as.numeric(c(performanceSexPrePostICC$ICC
                                      , groupClickSexPrePostICC$ICC
                                      , groupBondingSexPrePostICC$ICC
                                      , teamBondingSexPrePostICC$ICC
                                    )
                                  )
  team <- as.numeric(c(performanceTeamPrePostICC$ICC
                                      , groupClickTeamPrePostICC$ICC
                                      , groupBondingTeamPrePostICC$ICC
                                      , teamBondingTeamPrePostICC$ICC
                                    )
                                  )
  location <- as.numeric(c(performanceLocationPrePostICC$ICC
                                    , groupClickLocationPrePostICC$ICC
                                    , groupBondingLocationPrePostICC$ICC
                                    , teamBondingLocationPrePostICC$ICC
                                  )
                                )

  ICCTablePrePost <- data.frame(variable, session, sex, team, location)
  # round to 2dp
  ICCTablePrePost[,-1] <- round(ICCTablePrePost[,-1],2)

  ICCTable <- xtable(ICCTablePrePost,
                        caption = "Pre-Post Tournament intra class correlations by group",
                        label = "tab:ICCTablePrePost")
  align(ICCTable) <- "rrcccc"
  print(ICCTable, file="ICCTablePrePost.tex")
@











<<conditionResultsPrePostDrill, echo=F,eval=T>>=
  twc$condition <- factor(twc$condition, ordered = FALSE)


# groupPerformance:
          summary(conditionGroupPerfPrePost <- lmer(groupPerfChangePrePostNorm ~ condition
                                                  + arousalFactorPost
                                                  + fullOutcomeAvg
                                                  + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                                  + tipiExtraverted
                                                  + ( 1 |sessionName),
                                                    data = twc,
                                                    REML = F)
                )
        conditionGroupPerfPrePost.CIs <- confint.merMod(conditionGroupPerfPrePost, method = "Wald", level = 0.95)
                #calculate marginal (fixed) and conditional (random) R^2 for the model:
                #groupPerfExpClick.controls.R2 <- sem.model.fits(groupPerfExpClick.controls)



#groupComponentsSuccess (jAS):
        summary(conditionJASPrePost <- lmer(jointActionSuccessPost ~ condition
                                          + arousalFactorPost
                                          + fullOutcomeAvg
                                          + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                          + tipiExtraverted
                                          + ( 1 |sessionName),
                                            data = twc,
                                            REML = F)
                                  )
      conditionJASPrePost.CIs <- confint.merMod(conditionJASPrePost, method = "Wald", level = 0.95)

#indvidualPerformanceChangePrePostNorm
      summary(conditionIndPerfPrePost <- lmer(indPerfChangePrePostNorm ~ condition
                                        + arousalFactorPost
                                        + fullOutcomeAvg
                                        + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                        + tipiExtraverted
                                        + ( 1 |sessionName),
                                          data = twc,
                                          REML = F)
                )

    conditionIndPerfPrePost.CIs <- confint.merMod(conditionJASPrePost, method = "Wald", level = 0.95)

#indComponents... don't report?


#teamClickChange
    summary(conditionClickPrePost <- lmer(groupClickChangePrePostNorm ~ condition
                                            + arousalFactorPost
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                            + tipiExtraverted
                                            + ( 1 |sessionName),
                                              data = twc,
                                              REML = F)
          )

    conditionClickPrePost.CIs <- confint.merMod(conditionClickPrePost, method = "Wald", level = 0.95)

#groupBonding:
    summary(conditionBondingPrePost <- lmer(groupBondingChangePrePostNorm ~ condition
                                            + arousalFactorPost
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                            + tipiExtraverted
                                            + ( 1 |sessionName),
                                              data = twc,
                                              REML = F)
          )
      conditionBondingPrePost.CIs <- confint.merMod(conditionBondingPrePost, method = "Wald", level = 0.95)

#team(squad)Bonding:
    summary(conditionTeamBondingPrePost <- lmer(teamBondingChangePrePostNorm ~ condition
                                            + arousalFactorPost
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                            + tipiExtraverted
                                            + ( 1 |sessionName),
                                              data = twc,
                                              REML = F)
          )
  conditionTeamBondingPrePost.CIs <- confint.merMod(conditionTeamBondingPrePost, method = "Wald", level = 0.95)

@



















\myparagraph{Prediction 1: More positive perceptions of team performance relative to prior expectations will correlate with higer feelings of team click with the training group}

<<teamPerfExpClickScatter, fig.cap=''>>=
library(ggplot2)
library(tidyverse)
  groupPerfExpClickScatter <- ggplot(twc, aes(x=groupPerformance_3Norm, y=groupClickPostFactor)) +
                              geom_point(shape = 1) +
                              geom_smooth(method=lm, se=FALSE)   # Don't add shaded confidence region
  groupPerfExpClickScatter +
              xlab("Group Performance vs Expectations") +
              ylab("Team Click") +
              apatheme
@



Figure ~\ref{fig:teamPerfExpClickScatter} shows a strong positive correlation between violations of prior expectations concerning team performance and feelings of ``click'' with the training group post-Experiment.  The slope of this relationship appears to vary according to condition, as indicated on the scatterplot by the two non-parallel lines of best fit.

%MODEL:
<<groupPerfExpClickModel, echo=F,eval=T>>=
  twc$condition <- factor(twc$condition, levels = c("low", "high"),
                                ordered = is.ordered(twc$condition))
  twc$groupPerformance_3Norm <- scale(twc$groupPerformance_3)
  twc$indPerformance_3Norm <- scale(twc$indPerformance_3)

  #condition only:
    summary(conditionClick <- lmer(groupClickPostFactor ~ condition
                                            + arousalFactorPost
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                            + ( 1 |sessionName),
                                              data = twc,
                                              REML = F)
          )

  groupPerfExpClick.intercept <- lmer(groupClickPostFactor ~ 1 + ( 1 |sessionName),
                              data = twc,
                              REML = F)
  groupPerfExpClick.main <- lmer(groupClickPostFactor ~ groupPerformance_3Norm*condition +
                              ( 1 |sessionName),
                              data = twc,
                              REML = F)
  #summary(groupPerfExpClick.main)

  ##MAIN EFFECTS
  library(lmerTest)
  summary(groupPerfExpClick.main.controls <- lmer(groupClickPostFactor ~ groupPerformance_3Norm
                              + indPerformance_3Norm
                              + arousalFactorPost
                              + fullOutcomeAvg
                              + subjectiveCompetenceFactor + objectiveCompetenceFactor
                              + tipiExtraverted
                              + (groupPerformance_3Norm|sessionName),
                              data = twc,
                              REML = F)
                            )

  groupPerfExpClick.main.controlsCIs <- confint.merMod(groupPerfExpClick.main.controls, method = "Wald", level = 0.95)
  #calculate marginal (fixed) and conditional (random) R^2 for the model:
  #library(piecewiseSEM)
  #groupPerfExpClick.main.controls.R2 <- sem.model.fits(groupPerfExpClick.main.controls)

##INERACTION:
  summary(groupPerfExpClick.Int.controls <- lmer(groupClickPostFactor ~ groupPerformance_3Norm*condition
                              + indPerformance_3Norm
                              + arousalFactorPost
                              + fullOutcomeAvg
                              + subjectiveCompetenceFactor + objectiveCompetenceFactor
                              + tipiExtraverted
                              + (groupPerformance_3Norm|sessionName),
                              data = twc,
                              REML = F)
                            )

  #confint:
  groupPerfExpClick.controls.CIs <- confint.merMod(groupPerfExpClick.controls, method = "Wald", level = 0.95)
  #calculate marginal (fixed) and conditional (random) R^2 for the model:
  #groupPerfExpClick.controls.R2 <- rsquared(groupPerfExpClick.controls)

#install.packages("lsmeans")
#  library(lmerTest)
#install.packages("emmeans")
#install.packages("lattice")
#  library(emmeans)
#  lsmip(groupPerfExpClick.Int.controls, groupPerformance_3Norm ~ condition)

  #compare AIC's of
  anova(groupPerfExpClick.main.controls, groupPerfExpClick.Int.controls)
@


%A LMER was used to model the relationship between group performance expectation violations and group click.  Group Performance Expectations, Condition, and their interaction were included as fixed effects, and experiment session was modelled as a random effect (intercept and slope).  To control for perceptions of individual performance relative to prior expectations, post-Experiment arousal, the average performance outcome of each invasion drill trial, and subjective and objective measures of athlete technical competence, these factors were included as fixed effects.



%ASSUMPTIONS:
<<groupPerfExpClickAssumptionsHist, echo=F,eval=T>>=
  #1.historgram with density line
  groupPerfExpClickResid <- resid(groupPerfExpClick.main.controls, type = "pearson")
  hist(groupPerfExpClickResid,
       freq = FALSE,
       main = "Distribution of residuals \n (standardised)",
       xlab = "Residuals")
  lines(density(groupPerfExpClickResid, na.rm = TRUE))
  dev.copy(pdf, "TEM1Hist.pdf")
  dev.off()
  #non-normality
  groupPerfExpClickResid.Wald <- shapiro.test(groupPerfExpClickResid)
  psych::describe(groupPerfExpClickResid)
@
<<groupPerfExpClickAssumptionsScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(groupPerfExpClick.main.controls, main = "Scatterplot of Residuals \n (standardised)")
  dev.copy(pdf, "TEM1Scatter.pdf")
  dev.off()
@
<<groupPerfExpClickQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(groupPerfExpClick.main.controls), main = "Norm QQ Plot of Residuals")
  qqline(residuals(groupPerfExpClick.main.controls))
  dev.copy(pdf, "TEM1QQNorm.pdf")
  dev.off()
@
<<groupPerfExpClickCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)
 library(influence.ME)
 groupPerfExpClickInfl <- influence(groupPerfExpClick.main.controls, obs = TRUE)
  groupPerfExpClickCooksD <- cooks.distance(groupPerfExpClickInfl)
  groupPerfExpClickCooksDMAX <- max(groupPerfExpClickCooksD, na.rm = T)
  plot(groupPerfExpClickInfl,
        which = "cook",
        main = "Influential cases \n (Cook's Distance)",
        ylab = "participant",
        xlab = "cooks.distance")
  dev.copy(pdf, "TEM1CooksD.pdf")
  dev.off()

@

 Model residuals were normally distributed around zero
(
  \resdist
    \Sexpr{groupPerfExpClickResid.Wald$statistic} 0.98,
  \pvalue
    \Sexpr{groupPerfExpClickResid.Wald$p.value}
)
and an analysis of Cook's distances suggests that the model did not contain any observations that unjustifiably influenced parameter estimates
(all
  \cooksD
    \Sexpr{round(groupPerfExpClickCooksDMAX, digits = 2)}
  ,
  for full presentation of model assumptions, see Appendix Figure ~\ref{fig:M1Assumptions}).

Based on these assessments, the model provided a robust basis for the inference that---in line with predictions---more positive violation of expectations concerning group performance predicted stronger feelings of team click. Also as predicted, this result was moderated by experiment condition, such that the effect of group performance expectation violation on group click was stronger in the high difficulty condition.





\myparagraph{Prediction 1.a: Violations of expectations around team performance moderate the relationship between perceptions of joint action success and team click training group}

<<jASgroupPerfExpClickScatterLM, eval=T,echo=F>>=
  #twc$groupPerformance_3Norm <- scale(twc$groupPerformance_3)
  jASPerfExpCLick <- lm(groupClickPostFactor ~ jointActionSuccessPost*groupPerformance_3Norm, data = twc)
  ## use vcov() to get parameter variances and covariances for Kris’s interaction utility
  vcov(jASPerfExpCLick)
  ## degrees of freedom for the model from the summary of the regression model
  summary(jASPerfExpCLick)
  ## used the psych package’s describe function to get the mean and standard deviation of groupClick
  psych::describe(twc$groupClickPostFactor)

  min(twc$jointActionSuccessPost, na.rm=T)
  max(twc$jointActionSuccessPost, na.rm=T)

  ##OUTPUT##
  #http://www.quantpsy.org/interact/mlr2.htm

  #Simple Intercepts and Slopes at Conditional Values of Z
  #=======================================================
  #At Z = cv1... (-1SD)
  #  simple intercept = 0.16(0.1267), t=1.2626, p=0.2123
  #  simple slope     = 0.7371(0.0851), t=8.6581, p=0
  #At Z = cv2... (Mean)
  #  simple intercept = 0.2242(0.0737), t=3.0419, p=0.0037
  #  simple slope     = 0.6815(0.0894), t=7.6199, p=0
  #At Z = cv3... (+1SD)
  #  simple intercept = 0.2885(0.0931), t=3.0988, p=0.0031
  #  simple slope     = 0.6259(0.12), t=5.2164, p=0


  groupPerfExpJASClickScatterLM <- ggplot(twc, aes(x=jointActionSuccessPost,
                                        y=groupClickPostFactor, size=groupPerformance_3Norm)) + geom_point(alpha = .10)
  groupPerfExpJASClickScatterLM +
              theme(plot.title = element_text(size=12)) +
              xlab("Joint Action Success") +
              ylab("Team Click") +
              scale_size_continuous(guide = FALSE)+
              geom_abline(aes(intercept=0.16, slope=0.7371, linetype='-1SD PerfExpect'))+
              geom_abline(aes(intercept=0.2242, slope=0.6815, linetype='Mean PerfExpect'))+
              geom_abline(aes(intercept=0.2885, slope=0.6259, linetype='+1SD PerfExpect'))+
              scale_linetype_manual(values=c('dotted','dashed','solid'),
              breaks=c('-1SD \n PerfExpect','Mean \n PerfExpect','+1SD \n PerfExpect'),name='Simple\nSlope')  +
              apatheme +
              ggsave("groupPerfExpJASClickScatterLM.pdf")

@



MODELS
<<jASgroupPerfExpClickInt, echo=F,eval=T>>=
  summary(jASgroupPerfExpClick.int.controls <- lmer(groupClickPostFactor ~
                                            jointActionSuccessPost:groupPerformance_3Norm
                                            + indPerformancePost + arousalFactorPost
                                            + fullOutcomeAvg + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                            + (jointActionSuccessPost + groupPerformance_3Norm |sessionName),
                                            data = twc,
                                            REML = F)
                                      )
  #
  #the effect of X2 on Y depends on the level of X1, or vice versa
  jASgroupPerfExpClick.int.controls.CIs <- confint.merMod(jASgroupPerfExpClick.int.controls, method = "Wald")
  #calculate marginal (fixed) and conditional (random) R^2 for the model:
  #jASgroupPerfExpClick.int.controls.R2 <- sem.model.fits(jASgroupPerfExpClick.int.controls)
@

<<jASgroupPerfExpClickInt1, echo=F,eval=T>>=
    jASgroupPerfExpClick.int.controls1 <- lmer(groupClickPostFactor ~
                                              jointActionSuccessPost:groupPerformance_3Norm +
                                              arousalFactorPost + fullOutcomeAvg
                                              + (jointActionSuccessPost:groupPerformance_3Norm |sessionName),
                                              control = lmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)),
                                              data = twc,
                                              REML = F)
  summary(jASgroupPerfExpClick.int.controls1)
@





<<jASgroupPerfExpClickScatterLMER, eval=T, echo=F>>=
  #twc$groupPerformance_3Norm <- scale(twc$groupPerformance_3)
  summary(jASgroupPerfExpClick.int.controls)
  ## use vcov() to get parameter variances and covariances for Kris’s interaction utility
  vcov(jASgroupPerfExpClick.int.controls)
  ## degrees of freedom for the model from the summary of the regression model
  summary(jASgroupPerfExpClick.int.controls)
  ## used the psych package’s describe function to get the mean and standard deviation of jAS
  psych::describe(twc$jointActionSuccessPost)
  min(twc$groupPerformance_3Norm, na.rm=T)
  max(twc$groupPerformance_3Norm, na.rm=T)


  ##OUTPUT##
  #http://www.quantpsy.org/interact/mlr2.htm

  #Simple Intercepts and Slopes at Conditional Values of Z
  #=======================================================
  #  At Z = cv1...
  #    simple intercept = 0.0994(0.1914), t=0.5193, p=0.6072
  #    simple slope     = 0.6809(0.0785), t=8.6759, p=0
  #  At Z = cv2...
  #    simple intercept = 0.0754(0.0974), t=0.7738, p=0.4443
  #    simple slope     = 0.4945(0.0794), t=6.2289, p=0
  #  At Z = cv3...
  #    simple intercept = 0.0619(NaN), t=NaN, p=NaN
  #    simple slope     = 0.3892(0.0949), t=4.1003, p=0.0001


  jASGroupPerfExpClickScatterLMER <- ggplot(twc, aes(x=jointActionSuccessPost,
                                        y=groupClickPostFactor, size=groupPerformance_3Norm)) + geom_point(alpha = .10)
  jASGroupPerfExpClickScatterLMER +
              theme(plot.title = element_text(size=12)) +
              labs(x = 'Joint Action Success', y = "Team Click") +
              scale_size_continuous(guide=FALSE)+
              geom_abline(aes(intercept=0.0994, slope=0.6809, linetype= "-1SD \n Expect"))+
              geom_abline(aes(intercept=0.0754, slope=0.4945, linetype= "Mean \n Expect"))+
              geom_abline(aes(intercept=0.0619, slope=0.3892, linetype="+1SD \n Expect"))+
              scale_linetype_manual(values=c('dotted','dashed','solid'),
              breaks=c("-1SD \n Expect", "Mean \n Expect","+1SD \n Expect"),name="Group Performance \n Vs Expected") +
              apatheme +
              ggsave("jASgroupPerfExpClickScatterLMER.pdf")
@

Figure ~\ref{fig:teamPerfExpClickScatter} shows that the slope of the relationship between between perceptions of Joint Action Success and Team Click appears to be  moderated by perception of team performance relative to prior expectations, such that higher levels (+1 standard deviation) of group performance expectation violation results in an increase of the steepness of the slope.


A LMER model, with Joint Action Success, Group Performance Expectations, and their interaction included as fixed effects, and perceptions of individual component performance, post-Experiment arousal, and average performance outcome included as controls, confirmed that the negative interation effect of Group Performance Expectations and Joint Action Success on Team Click was significant
,
suggesting that the relationship between joint action success an group click is more pronounced for \textit{less} positive violations of expectations around group performance.


%%UNUSED MODEL:
<<groupPerfJASExpClick, eval=T,echo=F>>=
  #  groupPerfExpJASClick.int.controls <- lmer(groupClickPostFactor ~
  #                                              #groupPerformance_3Norm*jointActionSuccessPost + indPerformancePost + arousalFactorPost +
  #                                              (groupPerformance_3Norm |sessionName),
  #                                              data = twc,
  #                                              REML = F)
  #  summary(groupPerfExpJASClick.int.controls)
@

%ASSUMPTIONS:
<<jASgroupPerfExpClickIntHist, echo=F,eval=T>>=
  #1.historgram with density line
  jASgroupPerfExpClickIntResid <- resid(jASgroupPerfExpClick.int.controls, type = "pearson")
  hist(jASgroupPerfExpClickIntResid, freq = FALSE,
    main = "Distribution of M1a Residuals",
    xlab = "Residuals")
  lines(density(jASgroupPerfExpClickIntResid, na.rm = TRUE))
  dev.copy(pdf, "TE1aHist.pdf")
  dev.off()
  #non-normality
  jASgroupPerfExpClickIntResid.Wald <- shapiro.test(jASgroupPerfExpClickIntResid)
  psych::describe(jASgroupPerfExpClickIntResid)
@
<<jASgroupPerfExpClickIntScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(jASgroupPerfExpClick.int.controls, main = "Scatterplot of M1a Residuals")
  dev.copy(pdf, "TEM1aScatter.pdf")
  dev.off()
@
<<jASgroupPerfExpClick.int.controlsQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(jASgroupPerfExpClick.int.controls), main = "Norm QQ Plot of M1a Residuals")
  qqline(residuals(jASgroupPerfExpClick.int.controls))
  dev.copy(pdf, "TEM1aQQNorm.pdf")
  dev.off()
@
<<jASgroupPerfExpClick.intAssumptionsCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)

  library(influence.ME)
  jASgroupPerfExpClick.int.controlsInfl <- influence(jASgroupPerfExpClick.int.controls, obs = T)
  jASgroupPerfExpClickIntCooksD <- cooks.distance(jASgroupPerfExpClick.int.controlsInfl)
  jASgroupPerfExpClickIntCooksDMAX <- max(jASgroupPerfExpClickIntCooksD, na.rm = T) # 1.382886e+00 (row 28)
  plot(jASgroupPerfExpClick.int.controlsInfl,
          which = "cook",
          main = "M1a Influential Cases \n (Cook's Distance)",
          ylab = "participants",
          xlab = "cooks.distance")
    dev.copy(pdf, "TEM1aCooksD.pdf")
    dev.off()

  jASgroupPerfExpClickIntCooksD <- cooks.distance(jASgroupPerfExpClick.int.controls, delete = 28)
  jASgroupPerfExpClickIntCooksD <- exclude.influence(jASgroupPerfExpClick.int.controls, obs = 28)
  summary(jASgroupPerfExpClickIntCooksD)
  summary(jASgroupPerfExpClick.int.controls)


  #Exlcude influential case(s):
  #https://cran.r-project.org/web/packages/influence.ME/influence.ME.pdf

@



















\myparagraph{Prediction 2: Feelings of group click predict feelings of social bonding to the training group}

<<groupClickBondScatter, eval=F,echo=T>>=
  groupClickBondScatter <- ggplot(twc, aes(x=groupClickPostFactor, y=groupBondingFactorPost)) +
                              geom_point(shape = 1) +
                              geom_smooth(method=lm, se=F)   #  add shaded confidence region
  groupClickBondScatter +
  #              guides(color = guide_legend(title="Condition"))+
              theme(plot.title = element_text(size=12)) +
              labs(x = "Team Click", y = "Social Bonding")+
              apatheme +
              ggsave("groupClickBondScatter.pdf")
              #              scale_fill_
              #"Perceptions of Team Click \n predict feelings of Social Bonding to training group"
              #guides(fill=guide_legend("my awesome title"))
@

Figure ~\ref{fig:groupClickBondScatter} shows a clear relationship between Team Click and Social Bonding to the training group following the training group, with the slope for the high difficulty condition appearing slightly steeper than the low difficulty condition.

%%MODEL:
<<clickBondingModel, eval=T,echo=F>>=



  clickBonding.intercept <- lmer(groupBondingFactorPost ~ 1 + ( 1 |sessionName),
                              data = twc,
                              REML = F)
  clickBonding.main <- lmer(groupBondingFactorPost ~ groupClickPostFactor*condition +
                              ( groupClickPostFactor |sessionName),
                              data = twc,
                              REML = F)
  summary(clickBonding.main)

  summary(clickBonding.controls <- lmer(groupBondingFactorPost ~ groupClickPostFactor
                                          + arousalFactorPost
                                          + fullOutcomeAvg
                                          + subjectiveCompetenceFactor
                                          + objectiveCompetenceFactor
                                          + tipiExtraverted
                                          + (groupClickPostFactor|sessionName),
                                            data = twc,
                                            REML = F)
                                          )


  #CIs:
  clickBonding.controls.CIs <- confint.merMod(clickBonding.controls, method = "Wald")
  #calculate marginal (fixed) and conditional (random) R^2 for the model:
  #clickBonding.controls.R2 <- sem.model.fits(clickBonding.controls)


  #Check for interaction with condition:
  summary(clickBondingCondition.controls <- lmer(groupBondingFactorPost ~ groupClickPostFactor*condition
                                            + arousalFactorPost
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor
                                            + objectiveCompetenceFactor
                                            + tipiExtraverted
                                            + (groupClickPostFactor + condition |sessionName),
                                          data = twc,
                                          REML = F)
                                        )

 # interaction is not significant and so dropped from analysis
  #CIs:
  clickBondingCondition.controls.CIs <- confint.merMod(clickBondingCondition.controls, method = "Wald")
  #calculate marginal (fixed) and conditional (random) R^2 for the model:
  #clickBondingCondition.controls.R2 <- sem.model.fits(clickBondingCondition.controls)

anova(clickBonding.controls, clickBondingCondition.controls)

@

A LMER model (controlling for arousal, average trial performance outcome, and technical competence (subjective and objective)) revealed a strong positive relationship between feelings of group click and feelings of social bonding to the training group,

%ASSUMPTIONS:
<<clickBondingHist, echo=F,eval=T>>=
  #1.historgram with density line
  clickBondingResid <- resid(clickBonding.controls, type = "pearson")
  hist(clickBondingResid, freq = FALSE, main = "Distribution of residuals", xlab = "Residuals")
  lines(density(clickBondingResid, na.rm = TRUE))
  dev.copy(pdf, "TEM2Hist.pdf")
  dev.off()
  #non-normality
  clickBonding.controls.Wald <- shapiro.test(clickBondingResid)
  psych::describe(clickBondingResid)
@
<<clickBondingScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(clickBonding.controls, main = "Scatterplot of residuals")
  dev.copy(pdf, "TEM2Scatter.pdf")
  dev.off()
@
<<clickBondingQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(clickBonding.controls), main = "Norm QQ Plot of residuals")
  qqline(residuals(clickBonding.controls))
  dev.copy(pdf, "TEM2QQNorm.pdf")
  dev.off()
@
<<clickBondingCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)

  library(influence.ME)
  clickBonding.controls.Infl <- influence(clickBonding.controls, obs = T)
  clickBonding.controls.CooksD <- cooks.distance(clickBonding.controls.Infl)
  clickBonding.controls.CooksDMAX <- max(clickBonding.controls.CooksD, na.rm = T) # 1.382886e+00 (row 28)
  plot(clickBonding.controls.Infl,
          which = "cook",
          main = "Influential Cases \n (Cook's Distance)",
          ylab = "participants",
          xlab = "cooks.distance")
  dev.copy(pdf, "TEM2CooksD.pdf")
  dev.off()
@























\myparagraph{Prediction 2.2: Feelings of group click predict feelings of social bonding to provincial team}



\myparagraph{Post-Drill}

<<groupClickTeamBondScatter, eval=F,echo=T>>=
  groupClickTeamBondScatter <- ggplot(twc, aes(x=groupClickPostFactor, y=teamBondingFactorPost)) +
                              geom_point(shape = 1) +
                              geom_smooth(method=lm, se=F)   #  add shaded confidence region
  groupClickTeamBondScatter +
  #              guides(color = guide_legend(title="Condition"))+
              theme(plot.title = element_text(size=12)) +
              labs(x = "Team Click", y = "Social Bonding (Province)")+
              apatheme +
              ggsave("groupClickTeamBondScatter.pdf")
              #              scale_fill_
              #"Perceptions of Team Click \n predict feelings of Social Bonding to training group"
              #guides(fill=guide_legend("my awesome title"))
@

Figure ~\ref{fig:groupClickTeamBondScatter} shows a clear relationship between Team Click and Social Bonding to provincial team following the training group, with the slope for the high difficulty condition appearing slightly steeper than the low difficulty condition.

%%MODEL:
<<clickTeamBondingModel, eval=T,echo=F>>=



  clickTeamBonding.intercept <- lmer(teamBondingFactorPost ~ 1 + ( 1 |sessionName),
                              data = twc,
                              REML = F)
  clickTeamBonding.main <- lmer(teamBondingFactorPost ~ groupClickPostFactor*condition +
                              ( groupClickPostFactor |sessionName),
                              data = twc,
                              REML = F)
  summary(clickTeamBonding.main)

  summary(clickTeamBonding.controls <- lmer(teamBondingFactorPost ~ groupClickPostFactor
                                          + arousalFactorPost
                                          + fullOutcomeAvg
                                          + subjectiveCompetenceFactor
                                          + objectiveCompetenceFactor
                                          + tipiExtraverted
                                          + (groupClickPostFactor|sessionName),
                                            data = twc,
                                            REML = F)
                                          )


  #CIs:
  clickTeamBonding.controls.CIs <- confint.merMod(clickTeamBonding.controls, method = "Wald")
  #calculate marginal (fixed) and conditional (random) R^2 for the model:
  #clickBonding.controls.R2 <- sem.model.fits(clickBonding.controls)


  #Check for interaction with condition:
  summary(clickTeamBondingCondition.controls <- lmer(teamBondingFactorPost  ~ groupClickPostFactor*condition
                                            + arousalFactorPost
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor
                                            + objectiveCompetenceFactor
                                            + tipiExtraverted
                                            + (groupClickPostFactor + condition |sessionName),
                                          data = twc,
                                          REML = F)
                                        )

 # interaction is not significant and so dropped from analysis
  #CIs:
  clickTeamBondingCondition.controls.CIs <- confint.merMod(clickTeamBondingCondition.controls, method = "Wald")
  #calculate marginal (fixed) and conditional (random) R^2 for the model:
  #clickTeamBondingCondition.controls.R2 <- sem.model.fits(clickTeamBondingCondition.controls)

anova(clickTeamBonding.controls, clickTeamBondingCondition.controls)

@


%ASSUMPTIONS:
<<clickTeamBondingHist, echo=F,eval=T>>=
  #1.historgram with density line
  clickTeamBondingResid <- resid(clickTeamBonding.controls, type = "pearson")
  hist(clickTeamBondingResid, freq = FALSE, main = "Distribution of residuals", xlab = "Residuals")
  lines(density(clickTeamBondingResid, na.rm = TRUE))
  dev.copy(pdf, "TEM2TeamHist.pdf")
  dev.off()
  #non-normality
  clickTeamBonding.controls.Wald <- shapiro.test(clickTeamBondingResid)
  psych::describe(clickTeamBondingResid)
@
<<clickTeamBondingScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(clickTeamBonding.controls, main = "Scatterplot of residuals")
  dev.copy(pdf, "TEM2TeamScatter.pdf")
  dev.off()
@
<<clickTeamBondingQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(clickTeamBonding.controls), main = "Norm QQ Plot of residuals")
  qqline(residuals(clickTeamBonding.controls))
  dev.copy(pdf, "TEM2TeamQQNorm.pdf")
  dev.off()
@
<<clickTeamBondingCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)

  library(influence.ME)
  clickTeamBonding.controls.Infl <- influence(clickTeamBonding.controls, obs = T)
  clickTeamBonding.controls.CooksD <- cooks.distance(clickTeamBonding.controls.Infl)
  clickTeamBonding.controls.CooksDMAX <- max(clickTeamBonding.controls.CooksD, na.rm = T) # 1.382886e+00 (row 28)
  plot(clickTeamBonding.controls.Infl,
          which = "cook",
          main = "Influential Cases \n (Cook's Distance)",
          ylab = "participants",
          xlab = "cooks.distance")
  dev.copy(pdf, "TEM2TeamCooksD.pdf")
  dev.off()
@






\myparagraph{Prediction 2.2 (Pre- to Post-Drill)}

<<groupClickTeamBondingChangeCondition, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition

groupClickTeamBondingChange <- ggplot(twc,
                            aes(x=groupClickChangePrePostNorm, y=teamBondingChangePrePostNorm)) +
                            geom_point(shape = 1) +
                            geom_smooth(method=lm, se=FALSE)   # Don't add shaded confidence region
groupClickTeamBondingChange +
            xlab("Team Click Change") +
            ylab("Social Bonding (Province) Change") +
            apatheme +
            ggsave("groupClickTeamBondingChangeCondition.pdf")

#groupClickTeamBondingChange
@






<<groupClickTeamBondingChangeModel, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition
library(optimx)
summary(clickTeamBondingChange.lmer <- lmer(teamBondingChangePrePostNorm ~ groupClickChangePrePostNorm
                                    + (groupPerfChangePrePostNorm | sessionName)
                                    + indPerfChangePrePostNorm
                                    + fullOutcomeAvg
                                    + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                    + tipiExtraverted
                                    , data = twc
                                    , REML = FALSE
                                    , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE,  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                )
        )

clickTeamBondingChange.lmer.lmerCIs <- confint.merMod(clickTeamBondingChange.lmer, method = "Wald", level = 0.95)

@


<<groupClickTeamBondingChangeConditionModel, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition
#summary(clickTeamBondingChangeCondition.lmer <- lmer(groupTeamBondingChangePrePostNorm ~ groupClickChangePrePostNorm*condition
  #                                  + (groupPerfChangePrePostNorm + condition | sessionName)
    #                                + indPerfChangePrePostNorm
        #                            + fullOutcomeAvg
          #                          + subjectiveCompetenceFactor + objectiveCompetenceFactor
            #                        + tipiExtraverted
              #                      , data = twc
              #                      , REML = FALSE
                #                    , control = lmerControl(optimizer = "optimx",
                  #                    calc.derivs = FALSE,  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                #                )
        #)


    #    clickTeamBondingChangeCondition.lmerCIs <- confint.merMod(teamChangeCondition.lmer, method = "Wald", level = 0.95)
#anova(teamChange.lmer, teamChangeCondition.lmer)

@

%ASSUMPTIONS:
<<clickTeamBondChangeAssumptionsHist, echo=F,eval=T>>=
  #1.historgram with density line
  clickTeamBondChangeResid <- resid(clickTeamBondingChange.lmer, type = "pearson")
  hist(clickTeamBondChangeResid,
       freq = FALSE,
       main = "Distribution of residuals \n (standardised)",
       xlab = "Residuals")
  lines(density(clickTeamBondChangeResid, na.rm = TRUE))
  dev.copy(pdf, "TEM22TeamHist.pdf")
  dev.off()
  #non-normality
  clickTeamBondChangeResid.Wald <- shapiro.test(clickTeamBondChangeResid)
  psych::describe(clickTeamBondChangeResid)
@
<<clickTeamBondChangeAssumptionsScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(clickTeamBondingChange.lmer, main = "Scatterplot of residuals \n (standardised)")
  dev.copy(pdf, "TEM22TeamScatter.pdf")
  dev.off()
@
<<clickTeamBondChangeQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(clickTeamBondingChange.lmer), main = "Norm QQ Plot of residuals")
  qqline(residuals(clickTeamBondingChange.lmer))
  dev.copy(pdf, "TEM22TeamQQNorm.pdf")
  dev.off()
@
<<clickTeamBondChangeCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)
 library(influence.ME)
  clickTeamBondingChangeInfl <- influence(clickTeamBondingChange.lmer, obs = TRUE)
  clickTeamBondingChangeClickCooksD <- cooks.distance(clickTeamBondingChangeInfl)
  clickTeamBondingChangeClickCooksDMAX <- max(clickTeamBondingChangeClickCooksD, na.rm = T)
  plot(clickTeamBondingChangeInfl,
        which = "cook",
        main = "Influential cases \n (Cook's Distance)",
        ylab = "participant",
        xlab = "cooks.distance")
  dev.copy(pdf, "TEM22TeamCooksD.pdf")
  dev.off()

@

































\myparagraph{Prediction 3: More positive perceptions of team performance relative to expectations will predict higher levels of Social Bonding to the training group}


<<groupPerfExpBondConditionScatter, eval=T,echo=F, fig.cap= 'Positive violation of group performance expectations \n predict feelings of Social Bonding to training group'>>=
  groupPerfExpBondScatter <- ggplot(twc, aes(x=groupPerformance_3Norm, y=groupBondingFactorPost)) +
                              geom_point(shape = 1) +
                              geom_smooth(method=lm, se=FALSE)
  groupPerfExpBondScatter +
              theme(plot.title = element_text(size=12)) +
              xlab("Group Performance vs Prior Expectations") +
              ylab("Social Bonding") +
              apatheme +
              ggsave("groupPerfExpBondConditionScatter.pdf")
@

  %<<groupPerfExpBondScatter1, fig.cap=''>>=
  %  teamPerfExpBondScatter1 <- ggplot(twc, aes(x=groupPerformance_3Norm, y=groupBondingFactorPost)) + geom_point(shape = 1) +
  %                              geom_smooth(method=lm, se=FALSE)
  %  teamPerfExpBondScatter1 +
  %              ggtitle("Perceptions of Team Performance (vs prior expectations) \n %              theme(plot.title = element_text(size=12)) +
  %              xlab("Team Performance vs Prior Expectations") +
  %              ylab("Social Bonding") +
  %              apatheme
  %@
@
Figure ~\ref{fig:groupPerfExpBondConditionScatter} shows a positive relationship between violation of group performance expectations and Social Bonding to the training group.  The plot shows a pronounced difference in the slope of each experimental condition, suggesting that the relationship was stronger in the high difficulty condition.

%%MODEL:
<<groupPerfExpBondingModel, eval=T,echo=F>>=
library(optimx)
  #twc$condition <- factor(twc$condition, levels = c("low", "high"),
                                ordered = is.ordered(twc$condition))

  groupPerfExpBonding.intercept <- lmer(groupBondingFactorPost ~ 1 + ( 1 |sessionName),
                              data = twc,
                              REML = F)
  summary(groupPerfExpBondingCondition.main <- lmer(groupBondingFactorPost ~ groupPerformance_3Norm*condition
                                                  + (groupPerformance_3Norm |sessionName),
                                          data = twc,
                                          control = lmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)),
                                          REML = F)
                                        )

  summary(groupPerfExpBondingCondition.main)


#MAIN EFFECT:

  summary(groupPerfExpBonding.controls <- lmer(groupBondingFactorPost ~  groupPerformance_3Norm
                                                        + indPerformance_3Norm
                                                        + arousalFactorPost
                                                        + fullOutcomeAvg
                                                        + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                                        + tipiExtraverted
                                                        + (groupPerformance_3Norm |sessionName)
                                          , control = lmerControl(optimizer = "optimx", calc.derivs = FALSE,
                                                                optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                          , data = twc
                                          , REML = F
                                        )
                                    )

  groupPerfExpBonding.controls.CIs <- confint.merMod(groupPerfExpBonding.controls, method = "Wald")
#CONDITION INTERACTION:

    summary(groupPerfExpBondingCondition.controls <- lmer(groupBondingFactorPost ~  groupPerformance_3Norm*condition
                                                          + indPerformance_3Norm
                                                          + arousalFactorPost
                                                          + fullOutcomeAvg
                                                          + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                                          + tipiExtraverted
                                                          + (groupPerformance_3Norm |sessionName)
                                            , control = lmerControl(optimizer = "optimx", calc.derivs = FALSE,
                                                                  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                            , data = twc
                                            , REML = F
                                          )
                                      )

  #CIs:
  groupPerfExpBondingCondition.controls.CIs <- confint.merMod(groupPerfExpBondingCondition.controls, method = "Wald")
  #R^2s:
 # groupPerfExpBondingCondition.controls.R2 <- sem.model.fits(groupPerfExpBondingCondition.controls)

anova(groupPerfExpBonding.controls,groupPerfExpBondingCondition.controls)

@
A LMER model with group performance expectation violation, condition, and their interaction as fixed effects, experiment session as random effect (correlated slope and intercept), and controls, revealed a significant positive relationship between the interaction of group performance expectation violation and condition on social bonding


%ASSUMPTIONS:
<<groupPerfExpBondingConditionHist, echo=F,eval=T>>=
  #1.historgram with density line
  groupPerfExpBonding.controlsResid <- resid(groupPerfExpBonding.controls, type = "pearson")
  hist(groupPerfExpBonding.controlsResid, freq = FALSE, main = "Distribution of residuals", xlab = "Residuals")
  lines(density(groupPerfExpBonding.controlsResid, na.rm = TRUE))
  dev.copy(pdf, "TEM3Hist.pdf")
  dev.off()
  #non-normality
  groupPerfExpBonding.controlsResid.Wald <- shapiro.test(groupPerfExpBonding.controlsResid)
  psych::describe(groupPerfExpBonding.controlsResid)
@
<<groupPerfExpBondingConditionScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(groupPerfExpBonding.controls, main = "Scatterplot of residuals")
  dev.copy(pdf, "TEM3Scatter.pdf")
  dev.off()
@
<<groupPerfExpBondingConditionQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(groupPerfExpBonding.controls), main = "Norm QQ Plot of residuals")
  qqline(residuals(groupPerfExpBonding.controls))
  dev.copy(pdf, "TEM3QQNorm.pdf")
  dev.off()
@
<<groupPerfExpBondingConditionCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)
  groupPerfExpBonding.controls.Infl <- influence(groupPerfExpBonding.controls, obs = T)
  groupPerfExpBonding.controlsCooksD <- cooks.distance(
                                                      groupPerfExpBonding.controls.Infl)
  groupPerfExpBonding.controls.CooksDMAX <- max(groupPerfExpBonding.controlsCooksD,
                                                      na.rm = T) # 1.382886e+00 (row 28)
  plot(groupPerfExpBonding.controls.Infl,
        which = "cook",
        main = "Influential Cases \n (Cook's Distance)",
        ylab = "participants",
        xlab = "cooks.distance")
        dev.copy(pdf, "TEM3CooksD.pdf")
        dev.off()
@






\myparagraph{Prediction 3.2: More positive perceptions of team performance relative to expectations will predict higher levels of Social Bonding to the Provincial team}


<<groupPerfExpTeamBondConditionScatter, eval=T,echo=F, fig.cap= 'Positive violation of group performance expectations \n predict feelings of Social Bonding to training group'>>=
  groupPerfExpTeamBondScatter <- ggplot(twc, aes(x=groupPerformance_3Norm, y=groupBondingFactorPost)) +
                              geom_point(shape = 1) +
                              geom_smooth(method=lm, se=FALSE)
  groupPerfExpTeamBondScatter +
              theme(plot.title = element_text(size=12)) +
              xlab("Group Performance vs Prior Expectations") +
              ylab("Social Bonding") +
              apatheme +
              ggsave("groupPerfExpTeamBondConditionScatter.pdf")
@

  %<<groupPerfExpTeamBondScatter1, fig.cap=''>>=
  %  teamPerfExpBondScatter1 <- ggplot(twc, aes(x=groupPerformance_3Norm, y=groupBondingFactorPost)) + geom_point(shape = 1) +
  %                              geom_smooth(method=lm, se=FALSE)
  %  teamPerfExpBondScatter1 +
  %              ggtitle("Perceptions of Team Performance (vs prior expectations) \n %              theme(plot.title = element_text(size=12)) +
  %              xlab("Team Performance vs Prior Expectations") +
  %              ylab("Social Bonding") +
  %              apatheme
  %@
@
Figure ~\ref{fig:groupPerfExpTeamBondConditionScatter} shows a positive relationship between violation of group performance expectations and Social Bonding to the training group.  The plot shows a pronounced difference in the slope of each experimental condition, suggesting that the relationship was stronger in the high difficulty condition.

%%MODEL:
<<groupPerfExpTeamBondingModel, eval=T,echo=F>>=
library(optimx)
  #twc$condition <- factor(twc$condition, levels = c("low", "high"),
                                ordered = is.ordered(twc$condition))

  groupPerfExpTeamBonding.intercept <- lmer(groupBondingFactorPost ~ 1 + ( 1 |sessionName),
                              data = twc,
                              REML = F)
  summary(groupPerfExpTeamBondingCondition.main <- lmer(groupBondingFactorPost ~ groupPerformance_3Norm*condition
                                                  + (groupPerformance_3Norm |sessionName),
                                          data = twc,
                                          control = lmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)),
                                          REML = F)
                                        )

  summary(groupPerfExpTeamBondingCondition.main)


#MAIN EFFECT:

  summary(groupPerfExpTeamBonding.controls <- lmer(teamBondingFactorPost ~  groupPerformance_3Norm
                                                        + indPerformance_3Norm
                                                        + arousalFactorPost
                                                        + fullOutcomeAvg
                                                        + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                                        + tipiExtraverted
                                                        + (groupPerformance_3Norm |sessionName)
                                          , control = lmerControl(optimizer = "optimx", calc.derivs = FALSE,
                                                                optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                          , data = twc
                                          , REML = F
                                        )
                                    )

  groupPerfExpTeamBonding.controls.CIs <- confint.merMod(groupPerfExpTeamBonding.controls, method = "Wald")
#CONDITION INTERACTION:

    summary(groupPerfExpTeamBondingCondition.controls <- lmer(groupBondingFactorPost ~  groupPerformance_3Norm*condition
                                                          + indPerformance_3Norm
                                                          + arousalFactorPost
                                                          + fullOutcomeAvg
                                                          + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                                          + tipiExtraverted
                                                          + (groupPerformance_3Norm |sessionName)
                                            , control = lmerControl(optimizer = "optimx", calc.derivs = FALSE,
                                                                  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                            , data = twc
                                            , REML = F
                                          )
                                      )

  #CIs:
  groupPerfExpTeamBondingCondition.controls.CIs <- confint.merMod(groupPerfExpTeamBondingCondition.controls, method = "Wald")
  #R^2s:
 # groupPerfExpTeamBondingCondition.controls.R2 <- sem.model.fits(groupPerfExpTeamBondingCondition.controls)

anova(groupPerfExpTeamBonding.controls,groupPerfExpTeamBondingCondition.controls)

@
A LMER model with group performance expectation violation, condition, and their interaction as fixed effects, experiment session as random effect (correlated slope and intercept), and controls, revealed a significant positive relationship between the interaction of group performance expectation violation and condition on social bonding


%ASSUMPTIONS:
<<groupPerfExpTeamBondingConditionHist, echo=F,eval=T>>=
  #1.historgram with density line
  groupPerfExpTeamBonding.controlsResid <- resid(groupPerfExpTeamBonding.controls, type = "pearson")
  hist(groupPerfExpTeamBonding.controlsResid, freq = FALSE, main = "Distribution of residuals", xlab = "Residuals")
  lines(density(groupPerfExpTeamBonding.controlsResid, na.rm = TRUE))
  dev.copy(pdf, "TEM3Hist.pdf")
  dev.off()
  #non-normality
  groupPerfExpTeamBonding.controlsResid.Wald <- shapiro.test(groupPerfExpTeamBonding.controlsResid)
  psych::describe(groupPerfExpTeamBonding.controlsResid)
@
<<groupPerfExpTeamBondingConditionScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(groupPerfExpTeamBonding.controls, main = "Scatterplot of residuals")
  dev.copy(pdf, "TEM3Scatter.pdf")
  dev.off()
@
<<groupPerfExpTeamBondingConditionQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(groupPerfExpTeamBonding.controls), main = "Norm QQ Plot of residuals")
  qqline(residuals(groupPerfExpTeamBonding.controls))
  dev.copy(pdf, "TEM3QQNorm.pdf")
  dev.off()
@
<<groupPerfExpTeamBondingConditionCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)
  groupPerfExpTeamBonding.controls.Infl <- influence(groupPerfExpTeamBonding.controls, obs = T)
  groupPerfExpTeamBonding.controlsCooksD <- cooks.distance(
                                                      groupPerfExpTeamBonding.controls.Infl)
  groupPerfExpTeamBonding.controls.CooksDMAX <- max(groupPerfExpTeamBonding.controlsCooksD,
                                                      na.rm = T) # 1.382886e+00 (row 28)
  plot(groupPerfExpTeamBonding.controls.Infl,
        which = "cook",
        main = "Influential Cases \n (Cook's Distance)",
        ylab = "participants",
        xlab = "cooks.distance")
        dev.copy(pdf, "TEM3CooksD.pdf")
        dev.off()
@




















Model residuals were normally distributed around zero
(
  \resdist
    \Sexpr{jASgroupPerfExpClickIntResid.Wald$statistic},
  \pvalue
    \Sexpr{jASgroupPerfExpClickIntResid.Wald$p.value}
)
and all \cooksD were less than
  \Sexpr{round(groupPerfExpBondingCondition.controls.CooksDMAX, digits = 2)}
(
see model assumptions in Appendix  ~\ref{fig:M1aAssumptions}
)
.

These results suggested that the relationship between positive violation of group performance expectations and social bonding was significant, only in the high difficulty condition, and not overall accoss conditions.


\myparagraph{Prediction 4: Feelings of group click will mediate a relationship between more positive perceptions of team performance relative to prior expectations around group performance and social bonding to the group}

<<groupPerfExpClickBondMediationModel, eval=T,echo=F>>=

  #detach_package function for lmerTest
  detach_package <- function(pkg, character.only = FALSE)
{
  if(!character.only)
  {
    pkg <- deparse(substitute(pkg))
  }
  search_item <- paste("package", pkg, sep = ":")
  while(search_item %in% search())
  {
    detach(search_item, unload = TRUE, character.only = TRUE)
  }
  }
  detach_package("lmerTest", TRUE)

library(lme4)
 library(optimx)
#  library(lmerTest)
  ## Direct relationship X->Y: fit model and show summary
  summary(m1 <- lmer(groupBondingFactorPost ~ groupPerformance_3Norm
                                              + arousalFactorPost
                                              + fullOutcomeAvg
                                              + subjectiveCompetenceFactor
                                              + objectiveCompetenceFactor
                                              + tipiExtraverted
                                              + (groupPerformance_3Norm|sessionName)
                                              ,
                                              control = lmerControl(optimizer = "optimx", calc.derivs = FALSE,
                                                                    optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                              , data = twc
                                              , REML = F
                                            )
                                          )





  ## X->M fit model and show summary
  summary(m2 <- lmer(groupClickPostFactor ~ groupPerformance_3Norm
                                            + indPerformance_3Norm
                                            + arousalFactorPost
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                            + (groupPerformance_3Norm + condition |sessionName)
                                            , data = twc
                                            , REML = F
                                          )
                            )


  #install.packages("optimx")
  #library("optimx")
  ## M->Y fit model and show summary
  summary(m3 <- lmer(groupBondingFactorPost ~  groupPerformance_3Norm + groupClickPostFactor + groupPerformance_3Norm
                                      + arousalFactorPost
                                      + fullOutcomeAvg
                                      + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                      + tipiExtraverted
                                      + (groupPerformance_3Norm + groupClickPostFactor | sessionName)
                                      , data = twc
                                      , REML = FALSE
                                      , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                    )
                                  )
@




<<moderatedMediationPostExperimentTest, eval=T, echo=F>>=
library(mediation)
med.out.postExperiment <- mediate(m2, m3, treat = "groupPerformance_3Norm",
                                        mediator = "groupClickPostFactor")
  summary(med.out.postExperiment)


#med.out.postExperiment.High <- mediate(m2, m3, treat = "groupPerformance_3Norm",
#                                        mediator = "groupClickPostFactor",
                                      covariates = list(condition = "high"))
#  summary(med.out.postExperiment.High)


#med.out.postExperiment.Low <- mediate(m2, m3, treat = "groupPerformance_3Norm",
#                                        mediator = "groupClickPostFactor",
#                                      covariates = list(condition = "low"))
#  summary(med.out.postExperiment.Low)


@


<<groupPerfExpClickMediationPlot, eval=T,echo=F>>=
  plot(med.out.postExperiment, main = "Post-Drill mediation model")
  dev.copy(pdf, "groupPerfExpClickMediationPlot.pdf")
  dev.off()
@

<<groupPerfExpClickMediationPlotHigh, eval=T,echo=F>>=
#  plot(med.out.postExperiment.High, main = "High difficulty")
#  dev.copy(pdf, "groupPerfExpClickMediationPlotHigh.pdf")
#  dev.off()
@

<<groupPerfExpClickMediationPlotLow, eval=T,echo=F>>=
#  plot(med.out.postExperiment.Low, main = "Low difficulty")
#  dev.copy(pdf, "groupPerfExpClickMediationPlotLow.pdf")
#  dev.off()
@










Mediation analyses were conducted using linear mixed effects regressions in the Causal Mediation Analysis package in R (Version 4.4.5).  To make inferences concerning the average indirect and total effects, quasi-Bayesian Markov Chain Monte Carlo (MCMC) method based on normal approximation and 1000 simulations was used to estimate the 95\% Confidence Intervals \citep{Tofighi2016a,Imai2010}. MCMC estimation is a form of non-parametric bootstrapping whereby the sampling distribution for the effect of interest is not assumed to be normal but is instead simulated from the model estimates and their asymptotic variances and covariances \cite{Preacher2008}.

Results of the mediation analysis revealed significant average indirect effect of Group Performance Expectation Violation on Social Bonding attributable to Team Click,





\myparagraph{Discussion of post-Experiment results}































XXXX

\section{Pre- to Post Experiemnt Results}



\subsection{Prediction 1 (Pre- to Post)}

<<groupPerfClickChangeCondition, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition

groupPerfClickChange <- ggplot(twc,
                            aes(x=groupPerfChangePrePostNorm, y=groupClickChangePrePostNorm)) +
                            geom_point(shape = 1) +
                            geom_smooth(method=lm, se=FALSE)   # Don't add shaded confidence region
groupPerfClickChange +
            xlab("Group Performance Change") +
            ylab("Team Click Change") +
            apatheme +
            ggsave("groupPerfClickChangeCondition.pdf")

@


<<groupPerfClickChangeModel, eval=T, echo=F>>=
library(lmerTest)
library(lme4)
  library(optimx)
summary(perfClickChange.lmer <- lmer(groupClickChangePrePostNorm ~ groupPerfChangePrePostNorm
                                    + indPerfChangePrePostNorm
                                    + fullOutcomeAvg
                                    + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                    + tipiExtraverted
                                    + (groupPerfChangePrePostNorm | sessionName)
                                    , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE,  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                    , data = twc
                                    , REML = FALSE
                                )
        )

        perfClickChange.lmer.CIs <- confint.merMod(perfClickChange.lmer, method = "Wald", level = 0.95)



@

<<groupperfClickChangeConditionModel, eval=T, echo=F>>=
library(lmerTest)
summary(perfClickChangeCondition.lmer <- lmer(groupClickChangePrePostNorm ~ groupPerfChangePrePostNorm*condition
                                    + indPerfChangePrePostNorm
                                    + fullOutcomeAvg
                                    + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                    + tipiExtraverted
                                    + (groupPerfChangePrePostNorm + condition | sessionName)
                                    , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE,  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                    , data = twc
                                    , REML = FALSE
                                )
        )

  perfClickChangeCondition.lmer.CIs <- confint.merMod(perfClickChangeCondition.lmer, method = "Wald", level = 0.95)

anova(perfClickChange.lmer, perfClickChangeCondition.lmer)

@


%ASSUMPTIONS:
<<groupPerfClickChangeAssumptionsHist, echo=F,eval=T>>=
  #1.historgram with density line
  groupPerfClickChangeResid <- resid(perfClickChange.lmer, type = "pearson")
  hist(groupPerfClickChangeResid,
       freq = FALSE,
       main = "Distribution of residuals \n (standardised)",
       xlab = "Residuals")
  lines(density(groupPerfClickChangeResid, na.rm = TRUE))
  dev.copy(pdf, "TEM21Hist.pdf")
  dev.off()
  #non-normality
  groupPerfClickChangeResid.Wald <- shapiro.test(groupPerfClickChangeResid)
  psych::describe(groupPerfClickChangeResid)
@
<<groupPerfClickChangeAssumptionsScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(perfClickChange.lmer, main = "Scatterplot of residuals \n (standardised)")
  dev.copy(pdf, "TEM21Scatter.pdf")
  dev.off()
@
<<groupPerfClickChangeQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(perfClickChange.lmer), main = "Norm QQ Plot of residuals")
  qqline(residuals(perfClickChange.lmer))
  dev.copy(pdf, "TEM21QQNorm.pdf")
  dev.off()
@
<<groupPerfClickChangeCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)
 library(influence.ME)
  groupPerfChangeClickInfl <- influence(perfClickChange.lmer, obs = TRUE)
  groupPerfChangeClickCooksD <- cooks.distance(groupPerfChangeClickInfl)
  groupPerfChangeClickCooksDMAX <- max(groupPerfChangeClickCooksD, na.rm = T)
  plot(groupPerfChangeClickInfl,
        which = "cook",
        main = "Influential cases \n (Cook's Distance)",
        ylab = "participant",
        xlab = "cooks.distance")
  dev.copy(pdf, "TEM21CooksD.pdf")
  dev.off()

@










\subsection{Prediction 2.1 groupClickChange (Pre- to Post-Drill)}


<<groupClickBondingChangeCondition, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition

groupClickBondingChange <- ggplot(twc,
                            aes(x=groupClickChangePrePostNorm, y=groupBondingChangePrePostNorm)) +
                            geom_point(shape = 1) +
                            geom_smooth(method=lm, se=FALSE)   # Don't add shaded confidence region
groupClickBondingChange +
            xlab("Team Click Change") +
            ylab("Social Bonding Change") +
            apatheme +
            ggsave("groupClickBondingChangeCondition.pdf")

#groupClickBondingChange
@






<<groupClickBondingChangeModel, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition
library(optimx)
summary(clickBondingChange.lmer <- lmer(groupBondingChangePrePostNorm ~ groupClickChangePrePostNorm
                                    + (groupPerfChangePrePostNorm | sessionName)
                                    + indPerfChangePrePostNorm
                                    + fullOutcomeAvg
                                    + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                    + tipiExtraverted
                                    , data = twc
                                    , REML = FALSE
                                    , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE,  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                )
        )

clickBondingChange.lmer.lmerCIs <- confint.merMod(clickBondingChange.lmer, method = "Wald", level = 0.95)

@


<<groupClickBondingChangeConditionModel, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition
summary(clickBondingChangeCondition.lmer <- lmer(groupBondingChangePrePostNorm ~ groupClickChangePrePostNorm*condition
                                    + (groupPerfChangePrePostNorm + condition | sessionName)
                                    + indPerfChangePrePostNorm
                                    + fullOutcomeAvg
                                    + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                    + tipiExtraverted
                                    , data = twc
                                    , REML = FALSE
                                    , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE,  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                )
        )


          clickBondingChangeCondition.lmerCIs <- confint.merMod(clickBondingChangeCondition.lmer, method = "Wald", level = 0.95)
anova(clickBondingChange.lmer, clickBondingChangeCondition.lmer)

@

%ASSUMPTIONS:
<<clickBondChangeAssumptionsHist, echo=F,eval=T>>=
  #1.historgram with density line
  clickBondChangeResid <- resid(clickBondingChange.lmer, type = "pearson")
  hist(clickBondChangeResid,
       freq = FALSE,
       main = "Distribution of residuals \n (standardised)",
       xlab = "Residuals")
  lines(density(clickBondChangeResid, na.rm = TRUE))
  dev.copy(pdf, "TEM22Hist.pdf")
  dev.off()
  #non-normality
  clickBondChangeResid.Wald <- shapiro.test(clickBondChangeResid)
  psych::describe(clickBondChangeResid)
@
<<clickBondChangeAssumptionsScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(clickBondingChange.lmer, main = "Scatterplot of residuals \n (standardised)")
  dev.copy(pdf, "TEM22Scatter.pdf")
  dev.off()
@
<<clickBondChangeQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(clickBondingChange.lmer), main = "Norm QQ Plot of residuals")
  qqline(residuals(clickBondingChange.lmer))
  dev.copy(pdf, "TEM22QQNorm.pdf")
  dev.off()
@
<<clickBondChangeCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)
 library(influence.ME)
  clickBondingChangeInfl <- influence(clickBondingChange.lmer, obs = TRUE)
  clickBondingChangeClickCooksD <- cooks.distance(clickBondingChangeInfl)
  clickBondingChangeClickCooksDMAX <- max(clickBondingChangeClickCooksD, na.rm = T)
  plot(clickBondingChangeInfl,
        which = "cook",
        main = "Influential cases \n (Cook's Distance)",
        ylab = "participant",
        xlab = "cooks.distance")
  dev.copy(pdf, "TEM22CooksD.pdf")
  dev.off()

@



















\subsection{Prediction 3 (Pre- to Post-Drill)}

\subsection{Prediction 3.1 (Pre- to Post-Drill)}
<<groupPerfBondingChangeCondition, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition

groupPerfBondingChange <- ggplot(twc,
                            aes(x=groupPerfChangePrePostNorm, y=groupBondingChangePrePostNorm)) +
                            geom_point(shape = 1) +
                            geom_smooth(method=lm, se=FALSE)   # Don't add shaded confidence region
groupPerfBondingChange +
            xlab("Group Perf Change") +
            ylab("Group Bonding Change") +
            apatheme +
            ggsave("groupPerfBondingChangeCondition.pdf")

@


<<groupPerfBondingChangeModel, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition
library(optimx)
summary(perfBondingChange.lmer <- lmer(groupBondingChangePrePostNorm ~ groupPerfChangePrePostNorm
                                    + (groupPerfChangePrePostNorm | sessionName)
                                    + indPerfChangePrePostNorm
                                    + fullOutcomeAvg
                                    + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                    + tipiExtraverted
                                    , data = twc
                                    , REML = FALSE
                                    , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE,  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                )
        )

    perfBondingChange.lmer.CIs <- confint.merMod(perfBondingChange.lmer, method = "Wald", level = 0.95)



@

<<groupPerfBondingChangeConditionModel, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition
summary(perfBondingChangeCondition.lmer <- lmer(groupBondingChangePrePostNorm ~ groupPerfChangePrePostNorm*condition
                                    + indPerfChangePrePostNorm
                                    + fullOutcomeAvg
                                    + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                    + tipiExtraverted
                                    + (groupPerfChangePrePostNorm + condition | sessionName)
                                    , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE,  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                    , data = twc
                                    , REML = FALSE

                                )
        )

  perfBondingChangeCondition.lmer.CIs <- confint.merMod(perfBondingChangeCondition.lmer, method = "Wald", level = 0.95)

anova(perfBondingChange.lmer, perfBondingConditionChange.lmer)

@



%ASSUMPTIONS:
<<perfBondChangeAssumptionsHist, echo=F,eval=T>>=
  #1.historgram with density line
  perfBondChangeResid <- resid(perfBondingChange.lmer, type = "pearson")
  hist(perfBondChangeResid,
       freq = FALSE,
       main = "Distribution of residuals \n (standardised)",
       xlab = "Residuals")
  lines(density(perfBondChangeResid, na.rm = TRUE))
  dev.copy(pdf, "TEM23Hist.pdf")
  dev.off()
  #non-normality
  perfBondChangeResid.Wald <- shapiro.test(perfBondChangeResid)
  psych::describe(perfBondChangeResid)
@
<<perfBondChangeAssumptionsScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(perfBondingChange.lmer, main = "Scatterplot of residuals \n (standardised)")
  dev.copy(pdf, "TEM23Scatter.pdf")
  dev.off()
@
<<perfBondChangeQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(perfBondingChange.lmer), main = "Norm QQ Plot of residuals")
  qqline(residuals(perfBondingChange.lmer))
  dev.copy(pdf, "TEM23QQNorm.pdf")
  dev.off()
@
<<perfBondChangeCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)
 library(influence.ME)
  perfBondingChangeInfl <- influence(perfBondingChange.lmer, obs = TRUE)
  perfBondingChangeClickCooksD <- cooks.distance(perfBondingChangeInfl)
  perfBondingChangeClickCooksDMAX <- max(perfBondingChangeClickCooksD, na.rm = T)
  plot(perfBondingChangeInfl,
        which = "cook",
        main = "Influential cases \n (Cook's Distance)",
        ylab = "participant",
        xlab = "cooks.distance")
  dev.copy(pdf, "TEM23CooksD.pdf")
  dev.off()

@












\subsection{Prediction 3.2 (Pre- to Post-Drill) Province}


<<groupPerfTeamBondingChangeCondition, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition

groupPerfTeamBondingChange <- ggplot(twc,
                            aes(x=groupPerfChangePrePostNorm, y=teamBondingChangePrePostNorm)) +
                            geom_point(shape = 1) +
                            geom_smooth(method=lm, se=FALSE)   # Don't add shaded confidence region
groupPerfTeamBondingChange +
            xlab("Group Perf Change") +
            ylab("Social Bonding (Province) Change") +
            apatheme +
            ggsave("groupPerfTeamBondingChangeCondition.pdf")

@


<<groupPerfTeamBondingChangeModel, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition
library(optimx)
summary(perfTeamBondingChange.lmer <- lmer(teamBondingChangePrePostNorm ~ groupPerfChangePrePostNorm
                                    + (groupPerfChangePrePostNorm | sessionName)
                                    + indPerfChangePrePostNorm
                                    + fullOutcomeAvg
                                    + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                    + tipiExtraverted
                                    , data = twc
                                    , REML = FALSE
                                    , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE,  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                )
        )

    perfTeamBondingChange.lmer.CIs <- confint.merMod(perfTeamBondingChange.lmer, method = "Wald", level = 0.95)



@

<<groupPerfTeamBondingChangeConditionModel, eval=T, echo=F>>=
# ggplot scatter with a slope for each condition
summary(perfTeamBondingChangeCondition.lmer <- lmer(groupBondingChangePrePostNorm ~ groupPerfChangePrePostNorm*condition
                                    + indPerfChangePrePostNorm
                                    + fullOutcomeAvg
                                    + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                    + tipiExtraverted
                                    + (groupPerfChangePrePostNorm + condition | sessionName)
                                    , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE,  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                    , data = twc
                                    , REML = FALSE

                                )
        )

  perfTeamBondingChangeCondition.lmer.CIs <- confint.merMod(perfTeamBondingChangeCondition.lmer, method = "Wald", level = 0.95)

anova(perfTeamBondingChange.lmer, perfTeamBondingConditionChange.lmer)

@



%ASSUMPTIONS:
<<perfTeamBondChangeAssumptionsHist, echo=F,eval=T>>=
  #1.historgram with density line
  perfTeamBondChangeResid <- resid(perfTeamBondingChange.lmer, type = "pearson")
  hist(perfTeamBondChangeResid,
       freq = FALSE,
       main = "Distribution of residuals \n (standardised)",
       xlab = "Residuals")
  lines(density(perfTeamBondChangeResid, na.rm = TRUE))
  dev.copy(pdf, "TEM23Hist.pdf")
  dev.off()
  #non-normality
  perfTeamBondChangeResid.Wald <- shapiro.test(perfTeamBondChangeResid)
  psych::describe(perfTeamBondChangeResid)
@
<<perfTeamBondChangeAssumptionsScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(perfTeamBondingChange.lmer, main = "Scatterplot of residuals \n (standardised)")
  dev.copy(pdf, "TEM23Scatter.pdf")
  dev.off()
@
<<perfTeamBondChangeQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(perfTeamBondingChange.lmer), main = "Norm QQ Plot of residuals")
  qqline(residuals(perfTeamBondingChange.lmer))
  dev.copy(pdf, "TEM23QQNorm.pdf")
  dev.off()
@
<<perfTeamBondChangeCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)
 library(influence.ME)
  perfTeamBondingChangeInfl <- influence(perfTeamBondingChange.lmer, obs = TRUE)
  perfTeamBondingChangeClickCooksD <- cooks.distance(perfTeamBondingChangeInfl)
  perfTeamBondingChangeClickCooksDMAX <- max(perfTeamBondingChangeClickCooksD, na.rm = T)
  plot(perfTeamBondingChangeInfl,
        which = "cook",
        main = "Influential cases \n (Cook's Distance)",
        ylab = "participant",
        xlab = "cooks.distance")
  dev.copy(pdf, "TEM23CooksD.pdf")
  dev.off()

@












































\subsection{Prediction 4 (Pre- to Post Drill)}




<<groupPrePostChangeMediationModel, eval=T,echo=F>>=

  #detach_package function for lmerTest
  detach_package <- function(pkg, character.only = FALSE)
{
  if(!character.only)
  {
    pkg <- deparse(substitute(pkg))
  }
  search_item <- paste("package", pkg, sep = ":")
  while(search_item %in% search())
  {
    detach(search_item, unload = TRUE, character.only = TRUE)
  }
  }
  detach_package("lmerTest", TRUE)

  library(lme4)
 library(optimx)
 #library(lmerTest)
  ## Direct relationship X->Y: fit model and show summary
  summary(m1Change <- lmer(groupBondingChangePrePost ~ groupPerfChangePrePostNorm
                                              + indPerfChangePrePostNorm
                                              + fullOutcomeAvg
                                              + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                              + tipiExtraverted
                                              + (groupPerfChangePrePostNorm|sessionName)
                                              , control = lmerControl(optimizer = "optimx", calc.derivs = FALSE,
                                                                    optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                              , data = twc
                                              , REML = F
                                      )
                        )

  ## X->M fit model and show summary
  summary(m2Change <- lmer(groupClickChangePrePost ~ groupPerfChangePrePostNorm
                                            + indPerfChangePrePostNorm
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                            + tipiExtr
                                            + (groupPerfChangePrePostNorm|sessionName)
                                            , control = lmerControl(optimizer = "optimx", calc.derivs = FALSE,
                                                                  optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                            , data = twc
                                            , REML = F
                                    )
                      )

  #install.packages("optimx")
  #library("optimx")
  ## M->Y fit model and show summary

  summary(m3Change <- lmer(groupBondingChangePrePost ~  groupClickChangePrePost
                                          + groupPerfChangePrePostNorm
                                          + indPerfChangePrePostNorm
                                          + fullOutcomeAvg
                                          + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                          + tipiExtraverted
                                          + (1 + groupClickChangePrePost | sessionName)
                                          , control = lmerControl(optimizer = "optimx", calc.derivs = FALSE,
                                                                optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                          , data = twc
                                          , REML = F
                                  )
                    )

#Moderated mediation aprroach 1: two outputs (RPackage for Causal Mediation Analysis pg 11)

  library(mediation)
  med.out.groupPerfClickChange <- mediate(m2Change, m3Change, treat = "groupPerfChangePrePostNorm",
                                          mediator = "groupClickChangePrePost")
    summary(med.out.groupPerfClickChange)

  #med.out.groupPerfClickChange.High <- mediate(m2Change, m3Change, treat = "groupPerfChangePrePostNorm",
  #                                        mediator = "groupClickChangePrePost",
  #                                      covariates = list(condition = "high"))
  #  summary(med.out.groupPerfClickChange.High)


  #med.out.groupPerfClickChange.Low <- mediate(m2Change, m3Change, treat = "groupPerfChangePrePostNorm",
  #                                        mediator = "groupClickChangePrePost",
  #                                      covariates = list(condition = "low"))
  #  summary(med.out.groupPerfClickChange.Low)


  #Moderated mediation aprroach 2: t-test (RPackage for Causal Mediation Analysis pg 12)
  # currently unavailable for merMod 18.05.18

  #  test.modmed(med.out.groupPerfClickChange,
  #                        covariates.1 = list(condition = "high"),
  #                        covariates.2 = list(condition = "low"), sims = 100)
@

<<groupPerfExpClickChangeMedPlot, eval=T,echo=F>>=
plot(med.out.groupPerfClickChange, main = "Pre- to Post-Drill \n mediation model")
dev.copy(pdf, "groupPerfExpClickChangeMedPlot.pdf")
dev.off()
@


<<>>=
#plot(med.out.groupPerfClickChange.High, main = "High difficulty")
#dev.copy(pdf, "groupPerfExpClickChangeMedPlotHigh.pdf")
#dev.off()
@

<<groupPerfExpClickChangeMedPlotLow, eval=T,echo=F>>=
#plot(med.out.groupPerfClickChange.Low, main = "Low difficulty")
#dev.copy(pdf, "groupPerfExpClickChangeMedPlotLow.pdf")
#dev.off()
@
























\section{Appendix results: group performance components predict click and bonding}



\myparagraph{Prediction 1.A: More positive perceptions of components of team performance predict higher feelings of team click with the training group}

<<jointActionSuccessClickScatter, fig.cap=''>>=
library(ggplot2)
library(tidyverse)
  jointActionSuccessClickScatter <- ggplot(twc, aes(x=jointActionSuccessPost, y=groupClickPostFactor)) +
                              geom_point(shape = 1) +
                              geom_smooth(method=lm, se=FALSE)   # Don't add shaded confidence region
  jointActionSuccessClickScatter +
              xlab("Group Performance Components") +
              ylab("Team Click") +
              apatheme
@



%MODEL:
<<jointActionSuccessClickModel, echo=F,eval=T>>=



  jointActionSuccessClick.intercept <- lmer(groupClickPostFactor ~ 1 + ( 1 |sessionName),
                              data = twc,
                              REML = F)
  jointActionSuccessClick.main <- lmer(groupClickPostFactor ~ jointActionSuccessPost +
                              ( 1 |sessionName),
                              data = twc,
                              REML = F)
  #summary(jointActionSuccessClick.main)

  ##MAIN EFFECTS
  library(lmerTest)
  summary(jointActionSuccessClick.main.controls <- lmer(groupClickPostFactor ~ jointActionSuccessPost
                              + indPerformance_3Norm
                              + arousalFactorPost
                              + fullOutcomeAvg
                              + subjectiveCompetenceFactor + objectiveCompetenceFactor
                              + tipiExtraverted
                              + (groupPerformance_3Norm|sessionName),
                              data = twc,
                              REML = F)
                            )

  jointActionSuccessClick.main.controlsCIs <- confint.merMod(jointActionSuccessClick.main.controls, method = "Wald", level = 0.95)
  #calculate marginal (fixed) and conditional (random) R^2 for the model:
  #library(piecewiseSEM)
  #jointActionSuccessClick.main.controls.R2 <- sem.model.fits(groupPerfExpClick.main.controls)




@





%ASSUMPTIONS:
<<jointActionSuccessClickAssumptionsHist, echo=F,eval=T>>=
  #1.historgram with density line
  jointActionSuccessClickResid <- resid(jointActionSuccessClick.main.controls, type = "pearson")
  hist(jointActionSuccessClickResid,
       freq = FALSE,
       main = "Distribution of residuals \n (standardised)",
       xlab = "Residuals")
  lines(density(jointActionSuccessClickResid, na.rm = TRUE))
  dev.copy(pdf, "JAS1Hist.pdf")
  dev.off()
  #non-normality
  jointActionSuccessClickResid.Wald <- shapiro.test(jointActionSuccessClickResid)
  psych::describe(jointActionSuccessClickResid)
@
<<jointActionSuccessClickAssumptionsScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(jointActionSuccessClick.main.controls, main = "Scatterplot of Residuals \n (standardised)")
  dev.copy(pdf, "JAS1Scatter.pdf")
  dev.off()
@
<<jointActionSuccessClickQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(jointActionSuccessClick.main.controls), main = "Norm QQ Plot of Residuals")
  qqline(residuals(jointActionSuccessClick.main.controls))
  dev.copy(pdf, "JAS1QQNorm.pdf")
  dev.off()
@
<<jointActionSuccessClickCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)
 library(influence.ME)
 jointActionSuccessClickInfl <- influence(jointActionSuccessClick.main.controls, obs = TRUE)
  jointActionSuccessClickCooksD <- cooks.distance(jointActionSuccessClickInfl)
  jointActionSuccessClickCooksDMAX <- max(jointActionSuccessClickCooksD, na.rm = T)
  plot(jointActionSuccessClickInfl,
        which = "cook",
        main = "Influential cases \n (Cook's Distance)",
        ylab = "participant",
        xlab = "cooks.distance")
  dev.copy(pdf, "JAS1CooksD.pdf")
  dev.off()

@

















\myparagraph{Prediction 3: More positive perceptions of components of team performance predict higher levels of Social Bonding to the training group}


<<jointActionSuccessBondConditionScatter, eval=T,echo=F, fig.cap=''>>=
  groupPerfExpBondScatter <- ggplot(twc, aes(x=jointActionSuccessPost, y=groupBondingFactorPost)) +
                              geom_point(shape = 1) +
                              geom_smooth(method=lm, se=FALSE)
  groupPerfExpBondScatter +
              theme(plot.title = element_text(size=12)) +
              xlab("Group Performance Components") +
              ylab("Social Bonding") +
              apatheme +
              ggsave("jointActionSuccessBondingScatter.pdf")
@

  %<<groupPerfExpBondScatter1, fig.cap=''>>=
  %  teamPerfExpBondScatter1 <- ggplot(twc, aes(x=groupPerformance_3Norm, y=groupBondingFactorPost)) + geom_point(shape = 1) +
  %                              geom_smooth(method=lm, se=FALSE)
  %  teamPerfExpBondScatter1 +
  %              ggtitle("Perceptions of Team Performance (vs prior expectations) \n %              theme(plot.title = element_text(size=12)) +
  %              xlab("Team Performance vs Prior Expectations") +
  %              ylab("Social Bonding") +
  %              apatheme
  %@

%%MODEL:
<<groupPerfExpBondingModel, eval=T,echo=F>>=
library(optimx)
  #twc$condition <- factor(twc$condition, levels = c("low", "high"),
                        #        ordered = is.ordered(twc$condition))

  jointActionSuccessBonding.intercept <- lmer(groupBondingFactorPost ~ 1 + ( 1 |sessionName),
                              data = twc,
                              REML = F)
  summary(jointActionSuccessBondingCondition.main <- lmer(groupBondingFactorPost ~ jointActionSuccessPost
                                                  + (jointActionSuccessPost |sessionName),
                                          data = twc,
                                          control = lmerControl(optimizer = "optimx", calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE)),
                                          REML = F)
                                        )

  summary(jointActionSuccessBondingCondition.main)


#MAIN EFFECT:

  summary(jointActionSuccessBonding.controls <- lmer(groupBondingFactorPost ~  jointActionSuccessPost
                                                        + indPerformance_3Norm
                                                        + arousalFactorPost
                                                        + fullOutcomeAvg
                                                        + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                                        + tipiExtraverted
                                                        + (jointActionSuccessPost |sessionName)
                                          , control = lmerControl(optimizer = "optimx", calc.derivs = FALSE,
                                                                optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                          , data = twc
                                          , REML = F
                                        )
                                    )

  jointActionSuccessBonding.controls.CIs <- confint.merMod(jointActionSuccessBonding.controls, method = "Wald")
#CONDITION INTERACTION:
@




%ASSUMPTIONS:
<<jointActionSuccessBondingConditionHist, echo=F,eval=T>>=
  #1.historgram with density line
  jointActionSuccessBonding.controlsResid <- resid(jointActionSuccessBonding.controls, type = "pearson")
  hist(jointActionSuccessBonding.controlsResid, freq = FALSE, main = "Distribution of residuals", xlab = "Residuals")
  lines(density(jointActionSuccessBonding.controlsResid, na.rm = TRUE))
  dev.copy(pdf, "JAS3Hist.pdf")
  dev.off()
  #non-normality
  jointActionSuccessBonding.controlsResid.Wald <- shapiro.test(jointActionSuccessBonding.controlsResid)
  psych::describe(jointActionSuccessBonding.controlsResid)
@
<<jointActionSuccessBondingConditionScatter, echo=F,eval=T>>=
  #2.scatterPlot
  plot(jointActionSuccessBonding.controls, main = "Scatterplot of residuals")
  dev.copy(pdf, "JAS3Scatter.pdf")
  dev.off()
@
<<jointActionSuccessBondingConditionQQNorm, echo=F,eval=T>>=
  #3.qqNorm
  qqnorm(residuals(jointActionSuccessBonding.controls), main = "Norm QQ Plot of residuals")
  qqline(residuals(jointActionSuccessBonding.controls))
  dev.copy(pdf, "JAS3QQNorm.pdf")
  dev.off()
@
<<jointActionSuccessBondingConditionCooksD, echo=F,eval=T>>=
  #indluential cases
  #cook's distances all < 1, so no cause for concern, (Field 2012: 271)
  jointActionSuccessBonding.controls.Infl <- influence(jointActionSuccessBonding.controls, obs = T)
  jointActionSuccessBonding.controlsCooksD <- cooks.distance(
                                                      jointActionSuccessBonding.controls.Infl)
  jointActionSuccessBonding.controls.CooksDMAX <- max(jointActionSuccessBonding.controlsCooksD,
                                                      na.rm = T) # 1.382886e+00 (row 28)
  plot(jointActionSuccessBonding.controls.Infl,
        which = "cook",
        main = "Influential Cases \n (Cook's Distance)",
        ylab = "participants",
        xlab = "cooks.distance")
        dev.copy(pdf, "JAS3CooksD.pdf")
        dev.off()
@



















































\myparagraph{Prediction 4: Feelings of group click will mediate a relationship between more positive perceptions of team performance components and social bonding to the group}

<<jointActionSuccessClickBondMediationModel, eval=T,echo=F>>=

  #detach_package function for lmerTest
  detach_package <- function(pkg, character.only = FALSE)
{
  if(!character.only)
  {
    pkg <- deparse(substitute(pkg))
  }
  search_item <- paste("package", pkg, sep = ":")
  while(search_item %in% search())
  {
    detach(search_item, unload = TRUE, character.only = TRUE)
  }
  }
  detach_package("lmerTest", TRUE)

library(lme4)
 library(optimx)
#  library(lmerTest)
  ## Direct relationship X->Y: fit model and show summary
  summary(m1 <- lmer(groupBondingFactorPost ~ jointActionSuccessPost
                                              + arousalFactorPost
                                              + fullOutcomeAvg
                                              + subjectiveCompetenceFactor
                                              + objectiveCompetenceFactor
                                              + tipiExtraverted
                                              + (jointActionSuccessPost|sessionName)
                                              ,
                                              control = lmerControl(optimizer = "optimx", calc.derivs = FALSE,
                                                                    optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                              , data = twc
                                              , REML = F
                                            )
                                          )





  ## X->M fit model and show summary
  summary(m2 <- lmer(groupClickPostFactor ~ jointActionSuccessPost
                                            + indPerformance_3Norm
                                            + arousalFactorPost
                                            + fullOutcomeAvg
                                            + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                            + (jointActionSuccessPost |sessionName)
                                            , data = twc
                                            , REML = F
                                          )
                            )


  #install.packages("optimx")
  #library("optimx")
  ## M->Y fit model and show summary
  summary(m3 <- lmer(groupBondingFactorPost ~  jointActionSuccessPost + groupClickPostFactor
                                      + arousalFactorPost
                                      + fullOutcomeAvg
                                      + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                      + tipiExtraverted
                                      + (jointActionSuccessPost + groupClickPostFactor | sessionName)
                                      , data = twc
                                      , REML = FALSE
                                      , control = lmerControl(optimizer = "optimx",
                                      calc.derivs = FALSE, optCtrl = list(method = "nlminb", starttests = FALSE, kkt = FALSE))
                                    )
                                  )
@

m1
m2


<<jointACtionSuccessMediationPostExperimentTest, eval=T, echo=F>>=
library(mediation)
med.out.postExperimentJAS <- mediate(m2, m3, treat = "jointActionSuccessPost", mediator = "groupClickPostFactor")
  summary(med.out.postExperimentJAS)


#med.out.postExperiment.High <- mediate(m2, m3, treat = "groupPerformance_3Norm",
#                                        mediator = "groupClickPostFactor",
#                                      covariates = list(condition = "high"))
#  summary(med.out.postExperiment.High)


#med.out.postExperiment.Low <- mediate(m2, m3, treat = "groupPerformance_3Norm",
#                                        mediator = "groupClickPostFactor",
#                                      covariates = list(condition = "low"))
#  summary(med.out.postExperiment.Low)


@


<<jointActionSuccessClickMediationPlot, eval=T,echo=F>>=
  plot(med.out.postExperimentJAS, main = "Mediation model")
  dev.copy(pdf, "jointActionSuccessClickMediationPlot.pdf")
  dev.off()
@




\section{Team Bonding}


<<jointActionSuccessClickMediationPlot, eval=T,echo=F>>=
summary(conditionGroupPerfPost <- lmer(groupPerformance_3Norm ~ condition
                                        + arousalFactorPost
                                        + fullOutcomeAvg
                                        + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                        + tipiExtraverted
                                        + ( 1 |sessionName),
                                          data = twc,
                                          REML = F)
      )
conditionGroupPerfPost.CIs <- confint.merMod(conditionGroupPerfPost, method = "Wald", level = 0.95)

@








\section{Objective performance outcome predicts perceptions of performance relative to prior expectations}


<<objectivePerformancePerfExpectations, eval=T,echo=F>>=
#groupComponentsSuccess (jAS):
library(lmerTest)
        summary(objPerfGroupPerfExpect <- lmer(groupPerformance_3Norm ~ fullOutcomeAvg
                                          + arousalFactorPost
                                          + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                          + tipiExtraverted
                                          + ( 1 |sessionName),
                                            data = twc,
                                            REML = F)
                                  )
  objPerfGroupPerfExpect.CIs <- confint.merMod(objPerfGroupPerfExpect, method = "Wald", level = 0.95)


  summary(objPerfGroupPerfExpect.tries <- lmer(groupPerformance_3Norm ~ successTotals
                                    + arousalFactorPost
                                    + subjectiveCompetenceFactor + objectiveCompetenceFactor
                                    + tipiExtraverted
                                    + ( 1 |sessionName),
                                      data = twc,
                                      REML = F)
                            )
objPerfGroupPerfExpect.tries.CIs <- confint.merMod(objPerfGroupPerfExpect.tries, method = "Wald", level = 0.95)





@














\section{Discussion}

\end{document}
